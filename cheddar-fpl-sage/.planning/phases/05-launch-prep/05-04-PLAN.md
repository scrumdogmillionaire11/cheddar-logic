---
phase: 05-launch-prep
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - frontend/src/main.tsx
  - frontend/index.html
  - backend/main.py
  - backend/middleware/error_handler.py
autonomous: true

user_setup:
  - service: sentry
    why: "Error tracking for frontend and backend"
    env_vars:
      - name: VITE_SENTRY_DSN
        source: "Sentry Dashboard -> Project Settings -> Client Keys (DSN)"
      - name: SENTRY_DSN
        source: "Sentry Dashboard -> Project Settings -> Client Keys (DSN)"
    dashboard_config:
      - task: "Create Sentry account (free tier)"
        location: "https://sentry.io/signup/"
      - task: "Create project for frontend (React)"
        location: "Sentry Dashboard -> Projects -> Create Project"
      - task: "Create project for backend (Python/FastAPI)"
        location: "Sentry Dashboard -> Projects -> Create Project"
      - task: "Copy DSN keys for both projects"
        location: "Project Settings -> Client Keys (DSN)"
  - service: analytics
    why: "Privacy-friendly analytics"
    env_vars: []
    dashboard_config:
      - task: "Create Plausible or Umami account (choose based on preference)"
        location: "https://plausible.io or https://umami.is"
      - task: "Add site: cheddarlogic.com/fpl-sage"
        location: "Dashboard -> Add Website"
      - task: "Copy tracking script snippet"
        location: "Site Settings -> Installation"
  - service: discord
    why: "Alert notifications via webhook"
    env_vars:
      - name: DISCORD_WEBHOOK_URL
        source: "Discord Server Settings -> Integrations -> Webhooks"
    dashboard_config:
      - task: "Create webhook in Discord server for alerts"
        location: "Server Settings -> Integrations -> Webhooks -> New Webhook"
      - task: "Copy webhook URL"
        location: "Webhook settings"

must_haves:
  truths:
    - "Frontend errors are captured and sent to Sentry"
    - "Backend errors are captured and sent to Sentry"
    - "Page views are tracked via privacy-friendly analytics"
    - "Critical errors trigger Discord notifications"
  artifacts:
    - path: "frontend/src/main.tsx"
      provides: "Sentry initialization for frontend"
      contains: "Sentry.init"
    - path: "backend/main.py"
      provides: "Sentry initialization for backend"
      contains: "sentry_sdk.init"
    - path: "frontend/index.html"
      provides: "Analytics script tag"
      contains: "plausible|umami"
    - path: "backend/middleware/error_handler.py"
      provides: "Discord webhook alerting"
      contains: "discord.*webhook"
  key_links:
    - from: "frontend/src/main.tsx"
      to: "Sentry.io"
      via: "DSN configuration"
      pattern: "dsn.*sentry"
    - from: "backend/main.py"
      to: "Sentry.io"
      via: "SDK initialization"
      pattern: "sentry_sdk.init"
    - from: "backend/middleware/error_handler.py"
      to: "Discord webhook"
      via: "HTTP POST on error"
      pattern: "requests.post.*webhook"
---

<objective>
Integrate error tracking (Sentry), privacy-friendly analytics (Plausible/Umami), and Discord alerting for production monitoring. Capture crashes, track usage patterns, and alert on critical issues.

Purpose: Operational visibility. Know when things break, understand usage patterns, respond to incidents.
Output: Monitoring and observability stack integrated into frontend and backend.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-launch-prep/05-CONTEXT.md

# Frontend entry point
@frontend/src/main.tsx
@frontend/index.html

# Backend entry point
@backend/main.py
</context>

<tasks>

<task type="auto">
  <name>Integrate Sentry error tracking</name>
  <files>
    frontend/src/main.tsx
    backend/main.py
  </files>
  <action>
**Frontend integration:**

Install Sentry SDK:
```bash
cd frontend
npm install @sentry/react
```

Update `frontend/src/main.tsx` to initialize Sentry before React render:
```tsx
import * as Sentry from "@sentry/react";

// Initialize Sentry (only in production)
if (import.meta.env.PROD) {
  Sentry.init({
    dsn: import.meta.env.VITE_SENTRY_DSN,
    integrations: [
      Sentry.browserTracingIntegration(),
      Sentry.replayIntegration(),
    ],
    tracesSampleRate: 0.1, // 10% of transactions
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0, // Capture 100% of sessions with errors
    environment: import.meta.env.MODE,
  });
}

// Existing React render code...
```

**Backend integration:**

Install Sentry SDK:
```bash
cd backend
pip install sentry-sdk[fastapi]
# Add to requirements.txt
echo "sentry-sdk[fastapi]>=1.40.0" >> requirements.txt
```

Update `backend/main.py` to initialize Sentry at app startup:
```python
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
import os

# Initialize Sentry (only if DSN provided)
if sentry_dsn := os.getenv("SENTRY_DSN"):
    sentry_sdk.init(
        dsn=sentry_dsn,
        integrations=[FastApiIntegration()],
        traces_sample_rate=0.1,
        environment=os.getenv("ENVIRONMENT", "production"),
    )

# Existing FastAPI app setup...
```

Update `backend/.env.example` to document SENTRY_DSN variable.

Note: DSN values will be provided by user after Sentry account setup. Use environment variables, never hardcode.
  </action>
  <verify>
Check `frontend/src/main.tsx` contains Sentry.init() wrapped in production check.
Check `backend/main.py` contains sentry_sdk.init() with conditional DSN.
Verify Sentry SDK installed in both projects (check package.json and requirements.txt).
  </verify>
  <done>
Sentry error tracking integrated in both frontend and backend. Errors will be captured when DSN environment variables are set.
  </done>
</task>

<task type="auto">
  <name>Integrate privacy-friendly analytics</name>
  <files>
    frontend/index.html
  </files>
  <action>
Add analytics script to `frontend/index.html` in the <head> section.

**For Plausible (recommended for simplicity):**
```html
<script defer data-domain="cheddarlogic.com" src="https://plausible.io/js/script.js"></script>
```

**For Umami (self-hosted alternative):**
```html
<script defer src="https://analytics.umami.is/script.js" data-website-id="YOUR_WEBSITE_ID"></script>
```

Choose Plausible unless user has strong preference for self-hosted Umami.

**Why these services:**
- No cookies (GDPR-friendly)
- No personal data collection
- Simple script tag, no SDK needed
- Privacy-focused, no data sold
- Free tier sufficient for launch

**Configuration:**
- Script loads asynchronously (defer) - no performance impact
- Auto-tracks page views
- No custom events needed initially
- Works with SPA routing (detects route changes)

Document in backend/.env.example (comment only, no backend integration needed):
```
# Analytics (frontend only, via script tag in index.html)
# Plausible: data-domain="cheddarlogic.com"
# Umami: data-website-id from dashboard
```

Note: Actual data-website-id for Umami will be provided by user after account creation.
  </action>
  <verify>
Check `frontend/index.html` contains analytics script tag in <head>.
Script tag has `defer` attribute for non-blocking load.
Verify data-domain or data-website-id attribute is present (will use placeholder until user provides real ID).
  </verify>
  <done>
Analytics script integrated in frontend. Page views will be tracked once user configures analytics account and updates script with real credentials.
  </done>
</task>

<task type="auto">
  <name>Configure Discord webhook alerting</name>
  <files>
    backend/middleware/error_handler.py
  </files>
  <action>
Create `backend/middleware/error_handler.py` for Discord webhook alerting on critical errors:

```python
import os
import logging
from typing import Optional
import httpx

logger = logging.getLogger(__name__)

DISCORD_WEBHOOK_URL = os.getenv("DISCORD_WEBHOOK_URL")

async def send_discord_alert(
    title: str,
    message: str,
    severity: str = "error",
    details: Optional[dict] = None
):
    """Send alert to Discord webhook for critical errors."""
    if not DISCORD_WEBHOOK_URL:
        logger.warning("Discord webhook not configured, skipping alert")
        return

    # Color codes: red for error, orange for warning, yellow for info
    color_map = {
        "error": 0xFF0000,   # Red
        "warning": 0xFFA500, # Orange
        "info": 0xFFFF00,    # Yellow
    }

    embed = {
        "title": title,
        "description": message,
        "color": color_map.get(severity, 0xFF0000),
        "fields": [],
    }

    if details:
        for key, value in details.items():
            embed["fields"].append({
                "name": key,
                "value": str(value)[:1024],  # Discord field limit
                "inline": True
            })

    payload = {"embeds": [embed]}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(DISCORD_WEBHOOK_URL, json=payload, timeout=5.0)
            response.raise_for_status()
    except Exception as e:
        logger.error(f"Failed to send Discord alert: {e}")

# Example usage function for integration
async def alert_on_critical_error(error: Exception, context: dict):
    """Alert Discord on 500 errors, rate limit failures, Redis outages."""
    await send_discord_alert(
        title="ðŸš¨ FPL Sage Critical Error",
        message=f"Error: {type(error).__name__}",
        severity="error",
        details={
            "Error Type": type(error).__name__,
            "Message": str(error)[:500],
            **context
        }
    )
```

Update `backend/main.py` to use error handler for 500 errors:
```python
from middleware.error_handler import alert_on_critical_error

@app.exception_handler(500)
async def internal_error_handler(request, exc):
    await alert_on_critical_error(exc, {"path": request.url.path})
    # Return error response...
```

Add httpx to requirements.txt if not present:
```bash
echo "httpx>=0.24.0" >> backend/requirements.txt
```

Update `backend/.env.example`:
```
# Discord alerting
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/...
```

**Alert triggers (suggested thresholds, Claude's discretion):**
- 500 Internal Server Errors
- Redis connection failures
- FPL API timeouts (if > 5 in 5 minutes)
- Analysis job failures (if not user error)

Note: Webhook URL will be provided by user after Discord webhook creation.
  </action>
  <verify>
Check `backend/middleware/error_handler.py` exists with send_discord_alert function.
Verify it uses DISCORD_WEBHOOK_URL environment variable.
Check backend/.env.example documents DISCORD_WEBHOOK_URL.
Verify httpx is in requirements.txt.
  </verify>
  <done>
Discord webhook alerting configured for backend critical errors. Alerts will send when webhook URL environment variable is set.
  </done>
</task>

</tasks>

<verification>
Verify Sentry integration:
- Frontend has Sentry.init() in main.tsx (production only)
- Backend has sentry_sdk.init() in main.py
- Both use environment variables for DSN

Verify analytics integration:
- Frontend index.html has Plausible or Umami script tag
- Script has defer attribute for non-blocking load

Verify Discord integration:
- Backend has error_handler.py with webhook function
- Error handler uses DISCORD_WEBHOOK_URL environment variable
- Example usage integrated in main.py exception handler

All integrations:
- Use environment variables (never hardcode credentials)
- Fail gracefully if credentials not set (log warning, continue)
- Documented in .env.example
</verification>

<success_criteria>
- Sentry SDK installed and initialized in both frontend and backend
- Analytics script integrated in frontend HTML
- Discord webhook alerting configured in backend
- All credentials pulled from environment variables
- .env.example documents all new environment variables
- Monitoring stack ready for production once credentials provided
</success_criteria>

<output>
After completion, create `.planning/phases/05-launch-prep/05-04-SUMMARY.md`
</output>
