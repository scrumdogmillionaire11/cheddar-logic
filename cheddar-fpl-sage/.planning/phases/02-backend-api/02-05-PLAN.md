---
phase: 02-backend-api
plan: 05
type: execute
wave: 4
depends_on: ["02-03", "02-04"]
files_modified:
  - backend/exceptions.py
  - backend/main.py
  - tests/tests_new/test_api_integration.py
autonomous: false

must_haves:
  truths:
    - "All error responses have consistent JSON structure"
    - "FPL API errors return appropriate HTTP status codes"
    - "Integration tests verify full analysis flow"
    - "Server starts and handles requests end-to-end"
  artifacts:
    - path: "backend/exceptions.py"
      provides: "Custom exception classes and handlers"
      contains: "FPLAPIError"
    - path: "tests/tests_new/test_api_integration.py"
      provides: "End-to-end API tests"
      min_lines: 100
  key_links:
    - from: "backend/main.py"
      to: "backend/exceptions.py"
      via: "exception handler registration"
      pattern: "exception_handler"
---

<objective>
Define error response contracts, add exception handlers, and create integration tests.

Purpose: Ensure consistent error handling across all endpoints with proper HTTP status codes, and verify the complete API works end-to-end.

Output:
- Exception classes and handlers for common error cases
- Integration tests for full analysis flow
- Human verification of running server
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@backend/main.py
@backend/models/api_models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exception classes and handlers</name>
  <files>
    backend/exceptions.py
    backend/main.py
  </files>
  <action>
**Create backend/exceptions.py:**

```python
"""
Custom exceptions and error handlers for FPL Sage API.
Provides consistent error response format across all endpoints.
"""
from typing import Optional, Dict, Any
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging

logger = logging.getLogger(__name__)


class FPLSageError(Exception):
    """Base exception for FPL Sage API."""

    def __init__(
        self,
        message: str,
        code: str = "INTERNAL_ERROR",
        status_code: int = 500,
        detail: Optional[str] = None,
    ):
        self.message = message
        self.code = code
        self.status_code = status_code
        self.detail = detail
        super().__init__(message)


class FPLAPIError(FPLSageError):
    """Error from FPL API (upstream service)."""

    def __init__(self, message: str, detail: Optional[str] = None):
        super().__init__(
            message=message,
            code="FPL_API_ERROR",
            status_code=502,  # Bad Gateway for upstream errors
            detail=detail,
        )


class InvalidTeamError(FPLSageError):
    """Invalid or non-existent FPL team."""

    def __init__(self, team_id: int):
        super().__init__(
            message=f"Team {team_id} not found or invalid",
            code="INVALID_TEAM_ID",
            status_code=404,
            detail="The FPL team ID does not exist or is private",
        )


class AnalysisTimeoutError(FPLSageError):
    """Analysis took too long."""

    def __init__(self, analysis_id: str, timeout_seconds: int = 30):
        super().__init__(
            message=f"Analysis {analysis_id} timed out after {timeout_seconds}s",
            code="ANALYSIS_TIMEOUT",
            status_code=504,  # Gateway Timeout
            detail="The analysis took too long to complete. Please try again.",
        )


class DataValidationError(FPLSageError):
    """Data from FPL API failed validation."""

    def __init__(self, message: str, detail: Optional[str] = None):
        super().__init__(
            message=message,
            code="DATA_VALIDATION_ERROR",
            status_code=422,
            detail=detail,
        )


# Exception handlers

async def fpl_sage_error_handler(request: Request, exc: FPLSageError) -> JSONResponse:
    """Handler for FPL Sage custom exceptions."""
    logger.warning(f"FPLSageError: {exc.code} - {exc.message}")
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.message,
            "code": exc.code,
            "detail": exc.detail,
        },
    )


async def http_exception_handler(
    request: Request, exc: HTTPException
) -> JSONResponse:
    """Handler for standard HTTP exceptions."""
    # Handle detail that might be a dict (from our endpoints)
    if isinstance(exc.detail, dict):
        return JSONResponse(
            status_code=exc.status_code,
            content=exc.detail,
        )

    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": str(exc.detail),
            "code": f"HTTP_{exc.status_code}",
            "detail": None,
        },
    )


async def validation_exception_handler(
    request: Request, exc: RequestValidationError
) -> JSONResponse:
    """Handler for Pydantic validation errors."""
    errors = exc.errors()

    # Format validation errors nicely
    error_messages = []
    for error in errors:
        loc = " -> ".join(str(l) for l in error["loc"])
        msg = error["msg"]
        error_messages.append(f"{loc}: {msg}")

    return JSONResponse(
        status_code=422,
        content={
            "error": "Validation error",
            "code": "VALIDATION_ERROR",
            "detail": "; ".join(error_messages),
            "errors": errors,  # Include full error details for debugging
        },
    )


async def general_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """Catch-all handler for unhandled exceptions."""
    logger.exception(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "code": "INTERNAL_ERROR",
            "detail": "An unexpected error occurred. Please try again later.",
        },
    )


def register_exception_handlers(app):
    """Register all exception handlers with the app."""
    app.add_exception_handler(FPLSageError, fpl_sage_error_handler)
    app.add_exception_handler(HTTPException, http_exception_handler)
    app.add_exception_handler(StarletteHTTPException, http_exception_handler)
    app.add_exception_handler(RequestValidationError, validation_exception_handler)
    # Note: General exception handler should be last resort
    # Only uncomment in production:
    # app.add_exception_handler(Exception, general_exception_handler)
```

**Update backend/main.py** to register exception handlers:

Add import near top:
```python
from backend.exceptions import register_exception_handlers
```

Add after app creation, before middleware:
```python
# Register exception handlers
register_exception_handlers(app)
```

The updated main.py should have this structure:
```python
app = FastAPI(
    title="FPL Sage API",
    description="AI-powered FPL decision engine API",
    version="1.0.0",
    lifespan=lifespan,
)

# Register exception handlers FIRST
register_exception_handlers(app)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    ...
)
```
  </action>
  <verify>
```bash
cd /Users/ajcolubiale/projects/cheddar-fpl-sage
python -m py_compile backend/exceptions.py
python -m py_compile backend/main.py
```
  </verify>
  <done>
- Custom exception classes created (FPLAPIError, InvalidTeamError, etc.)
- Exception handlers registered in main.py
- All errors return consistent JSON format: {error, code, detail}
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests</name>
  <files>
    tests/tests_new/test_api_integration.py
  </files>
  <action>
**Create tests/tests_new/test_api_integration.py:**

```python
"""
Integration tests for FPL Sage API.
Tests the full request/response cycle and error handling.
"""
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from fastapi.testclient import TestClient
import sys
import os
import json
import time

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'backend'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'src'))

from backend.main import app
from backend.exceptions import FPLAPIError, InvalidTeamError


@pytest.fixture
def client():
    """Create test client."""
    return TestClient(app)


class TestErrorResponseFormat:
    """Tests for consistent error response format."""

    def test_validation_error_format(self, client):
        """Validation errors have consistent format."""
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": "not_a_number"}
        )
        assert response.status_code == 422
        data = response.json()

        # Required fields
        assert "error" in data
        assert "code" in data
        assert data["code"] == "VALIDATION_ERROR"

    def test_not_found_error_format(self, client):
        """404 errors have consistent format."""
        response = client.get("/api/v1/analyze/nonexistent123")
        assert response.status_code == 404
        data = response.json()

        assert "error" in data
        assert "code" in data
        assert "ANALYSIS_NOT_FOUND" in data["code"] or "NOT_FOUND" in str(data)

    def test_invalid_team_id_format(self, client):
        """Invalid team_id errors have consistent format."""
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 0}
        )
        assert response.status_code == 400
        data = response.json()

        assert "error" in data
        assert "code" in data
        assert data["code"] == "INVALID_TEAM_ID"


class TestAnalysisFlow:
    """Tests for the complete analysis flow."""

    def test_create_and_poll_analysis(self, client):
        """Can create analysis and poll for status."""
        # Create analysis
        create_response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345}
        )
        assert create_response.status_code == 202
        analysis_id = create_response.json()["analysis_id"]

        # Poll for status
        status_response = client.get(f"/api/v1/analyze/{analysis_id}")
        assert status_response.status_code == 200

        status_data = status_response.json()
        assert "status" in status_data
        assert status_data["status"] in ["queued", "running", "completed", "failed"]

    def test_analysis_with_gameweek(self, client):
        """Can specify gameweek for analysis."""
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345, "gameweek": 25}
        )
        assert response.status_code == 202

    def test_analysis_gameweek_boundaries(self, client):
        """Gameweek validation at boundaries."""
        # Valid: GW1
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345, "gameweek": 1}
        )
        assert response.status_code == 202

        # Valid: GW38
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345, "gameweek": 38}
        )
        assert response.status_code == 202

        # Invalid: GW0
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345, "gameweek": 0}
        )
        assert response.status_code == 400

        # Invalid: GW39
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345, "gameweek": 39}
        )
        assert response.status_code == 400


class TestHealthAndMetadata:
    """Tests for health and informational endpoints."""

    def test_health_endpoint(self, client):
        """Health endpoint returns expected fields."""
        response = client.get("/health")
        assert response.status_code == 200
        data = response.json()

        assert data["status"] == "healthy"
        assert "version" in data
        assert "timestamp" in data
        assert "redis" in data

    def test_root_endpoint(self, client):
        """Root endpoint returns API info."""
        response = client.get("/")
        assert response.status_code == 200
        data = response.json()

        assert data["name"] == "FPL Sage API"
        assert "docs" in data

    def test_docs_endpoint(self, client):
        """OpenAPI docs are available."""
        response = client.get("/docs")
        assert response.status_code == 200

    def test_openapi_schema(self, client):
        """OpenAPI schema is valid."""
        response = client.get("/openapi.json")
        assert response.status_code == 200
        schema = response.json()

        assert "openapi" in schema
        assert "paths" in schema
        assert "/api/v1/analyze" in schema["paths"]


class TestRateLimitHeaders:
    """Tests for rate limit headers."""

    def test_rate_limit_headers_present(self, client):
        """Rate limit headers included in responses."""
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345}
        )

        # Headers may not be present if Redis not available (graceful degradation)
        # But if present, should have correct format
        if "X-RateLimit-Limit" in response.headers:
            assert int(response.headers["X-RateLimit-Limit"]) > 0
            assert "X-RateLimit-Remaining" in response.headers

    def test_health_skips_rate_limit(self, client):
        """Health endpoint is not rate limited."""
        # Make many requests to health
        for _ in range(10):
            response = client.get("/health")
            assert response.status_code == 200


class TestCacheHeaders:
    """Tests for cache-related headers."""

    def test_cache_miss_no_header(self, client):
        """Fresh analysis doesn't have X-Cache header."""
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 99999}  # Unlikely to be cached
        )
        # Cache miss = 202 queued, not 200 cached
        if response.status_code == 202:
            assert response.headers.get("X-Cache") != "HIT"


class TestWebSocketIntegration:
    """Integration tests for WebSocket functionality."""

    def test_websocket_invalid_job_closes(self, client):
        """WebSocket for invalid job closes gracefully."""
        with client.websocket_connect("/api/v1/analyze/invalid123/stream") as ws:
            data = ws.receive_json()
            assert data["type"] == "error"
            assert data["code"] == "ANALYSIS_NOT_FOUND"

    def test_websocket_valid_job_connects(self, client):
        """WebSocket for valid job connects successfully."""
        # Create job
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345}
        )
        analysis_id = response.json()["analysis_id"]

        # Connect WebSocket
        with client.websocket_connect(f"/api/v1/analyze/{analysis_id}/stream") as ws:
            data = ws.receive_json()
            assert data["type"] in ["progress", "heartbeat", "complete", "error"]


class TestExceptionHandlers:
    """Tests for custom exception handling."""

    def test_fpl_api_error_returns_502(self, client):
        """FPL API errors return 502 Bad Gateway."""
        from backend.services.engine_service import engine_service

        # Create a job
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345}
        )
        analysis_id = response.json()["analysis_id"]

        # Manually set job to failed with FPL error
        job = engine_service.get_job(analysis_id)
        job.status = "failed"
        job.error = "FPL API returned 503"

        # Check status
        status_response = client.get(f"/api/v1/analyze/{analysis_id}")
        assert status_response.status_code == 200
        data = status_response.json()
        assert data["status"] == "failed"
        assert "FPL API" in data["error"]


class TestFullApiCoverage:
    """Ensure all documented endpoints work."""

    def test_post_analyze(self, client):
        """POST /api/v1/analyze works."""
        response = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345}
        )
        assert response.status_code in [200, 202]

    def test_get_analyze_status(self, client):
        """GET /api/v1/analyze/{id} works."""
        # Create first
        create = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345}
        )
        aid = create.json()["analysis_id"]

        # Then get
        response = client.get(f"/api/v1/analyze/{aid}")
        assert response.status_code == 200

    def test_websocket_stream(self, client):
        """WS /api/v1/analyze/{id}/stream works."""
        # Create job
        create = client.post(
            "/api/v1/analyze",
            json={"team_id": 12345}
        )
        aid = create.json()["analysis_id"]

        # Connect WebSocket
        with client.websocket_connect(f"/api/v1/analyze/{aid}/stream") as ws:
            data = ws.receive_json()
            assert "type" in data
```
  </action>
  <verify>
```bash
cd /Users/ajcolubiale/projects/cheddar-fpl-sage

# Run integration tests
PYTHONPATH=src:backend python -m pytest tests/tests_new/test_api_integration.py -v
```
  </verify>
  <done>
- test_api_integration.py has 20+ test cases
- Tests cover error format, analysis flow, health, rate limits, cache, WebSocket
- All documented endpoints tested
- All tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete FastAPI backend with:
- POST /api/v1/analyze - trigger analysis
- GET /api/v1/analyze/{id} - poll status
- WS /api/v1/analyze/{id}/stream - real-time progress
- Rate limiting and caching (requires Redis)
- Consistent error handling
  </what-built>
  <how-to-verify>
1. Install backend dependencies:
   ```bash
   cd /Users/ajcolubiale/projects/cheddar-fpl-sage
   pip install -r backend/requirements.txt
   ```

2. Start the server:
   ```bash
   PYTHONPATH=src:backend uvicorn backend.main:app --reload --port 8000
   ```

3. Open browser to http://localhost:8000/docs
   - Verify Swagger UI loads
   - See all endpoints documented

4. Test health endpoint:
   ```bash
   curl http://localhost:8000/health
   ```
   Expected: {"status": "healthy", "version": "1.0.0", ...}

5. Trigger an analysis (use your real FPL team ID or 12345 for test):
   ```bash
   curl -X POST http://localhost:8000/api/v1/analyze \
     -H "Content-Type: application/json" \
     -d '{"team_id": 12345}'
   ```
   Expected: {"analysis_id": "...", "status": "queued", ...}

6. Poll for status using the returned analysis_id:
   ```bash
   curl http://localhost:8000/api/v1/analyze/{analysis_id}
   ```
   Expected: {"status": "queued|running|completed|failed", ...}

7. Test invalid team ID:
   ```bash
   curl -X POST http://localhost:8000/api/v1/analyze \
     -H "Content-Type: application/json" \
     -d '{"team_id": 0}'
   ```
   Expected: 400 error with code "INVALID_TEAM_ID"
  </how-to-verify>
  <resume-signal>Type "approved" if server runs and endpoints work, or describe issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd /Users/ajcolubiale/projects/cheddar-fpl-sage

# 1. Run full test suite
PYTHONPATH=src:backend python -m pytest tests/tests_new/test_api_*.py tests/tests_new/test_websocket_*.py tests/tests_new/test_rate_*.py -v

# 2. Count tests
PYTHONPATH=src:backend python -m pytest tests/tests_new/test_api_*.py tests/tests_new/test_websocket_*.py tests/tests_new/test_rate_*.py --collect-only | grep "test_" | wc -l

# 3. Verify all backend files compile
find backend -name "*.py" -exec python -m py_compile {} \;
echo "All backend files compile successfully"
```
</verification>

<success_criteria>
- Custom exceptions return consistent JSON format
- Exception handlers registered in main.py
- 20+ integration tests pass
- Server starts and responds to all documented endpoints
- Human verification confirms server works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-api/02-05-SUMMARY.md`
</output>
