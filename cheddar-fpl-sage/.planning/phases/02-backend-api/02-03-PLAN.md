---
phase: 02-backend-api
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - backend/routers/analyze.py
  - backend/services/engine_service.py
  - tests/tests_new/test_websocket_progress.py
autonomous: true

must_haves:
  truths:
    - "WebSocket connection can be established to /api/v1/analyze/{id}/stream"
    - "Progress updates are sent as JSON messages during analysis"
    - "WebSocket closes gracefully when analysis completes"
    - "Client receives phase and progress percentage updates"
  artifacts:
    - path: "backend/routers/analyze.py"
      provides: "WebSocket endpoint"
      contains: "@router.websocket"
    - path: "backend/services/engine_service.py"
      provides: "Progress callback mechanism"
      contains: "register_progress_callback"
  key_links:
    - from: "backend/routers/analyze.py"
      to: "backend/services/engine_service.py"
      via: "progress callback registration"
      pattern: "register_progress_callback"
---

<objective>
Implement WebSocket endpoint for real-time analysis progress streaming.

Purpose: Allow frontend to receive live progress updates during analysis instead of polling, providing better UX with real-time feedback.

Output:
- WS /api/v1/analyze/{analysis_id}/stream endpoint
- Progress messages with phase and percentage
- Graceful connection handling
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-backend-api/02-02-SUMMARY.md
@backend/routers/analyze.py
@backend/services/engine_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebSocket endpoint to router</name>
  <files>
    backend/routers/analyze.py
  </files>
  <action>
**Add WebSocket endpoint to backend/routers/analyze.py:**

Add these imports at the top:
```python
from fastapi import WebSocket, WebSocketDisconnect
import asyncio
import json
```

Add WebSocket endpoint after existing endpoints:

```python
@router.websocket("/{analysis_id}/stream")
async def stream_analysis_progress(websocket: WebSocket, analysis_id: str):
    """
    WebSocket endpoint for streaming analysis progress.

    Connect to receive real-time updates during analysis:
    - {"type": "progress", "progress": 25.0, "phase": "collecting_data"}
    - {"type": "complete", "results": {...}}
    - {"type": "error", "error": "..."}

    Connection closes automatically when analysis completes or fails.
    """
    await websocket.accept()
    logger.info(f"WebSocket connected for analysis {analysis_id}")

    job = engine_service.get_job(analysis_id)
    if not job:
        await websocket.send_json({
            "type": "error",
            "error": "Analysis not found",
            "code": "ANALYSIS_NOT_FOUND",
        })
        await websocket.close(code=4004)
        return

    # If already completed, send result and close
    if job.status == "completed":
        await websocket.send_json({
            "type": "complete",
            "results": job.results,
        })
        await websocket.close()
        return

    if job.status == "failed":
        await websocket.send_json({
            "type": "error",
            "error": job.error,
        })
        await websocket.close(code=4000)
        return

    # Create async queue for progress updates
    progress_queue: asyncio.Queue = asyncio.Queue()

    def on_progress(progress: float, phase: str):
        """Callback invoked by engine service on progress."""
        try:
            progress_queue.put_nowait({"progress": progress, "phase": phase})
        except asyncio.QueueFull:
            pass  # Drop if queue is full (shouldn't happen)

    # Register callback
    engine_service.register_progress_callback(analysis_id, on_progress)

    try:
        # Send current state
        await websocket.send_json({
            "type": "progress",
            "progress": job.progress,
            "phase": job.phase or "queued",
        })

        # Stream updates until complete
        while True:
            # Check if job completed
            job = engine_service.get_job(analysis_id)
            if not job:
                break

            if job.status == "completed":
                await websocket.send_json({
                    "type": "complete",
                    "results": job.results,
                })
                break

            if job.status == "failed":
                await websocket.send_json({
                    "type": "error",
                    "error": job.error,
                })
                break

            # Wait for progress update with timeout
            try:
                update = await asyncio.wait_for(
                    progress_queue.get(),
                    timeout=2.0  # Poll every 2 seconds max
                )
                await websocket.send_json({
                    "type": "progress",
                    **update,
                })
            except asyncio.TimeoutError:
                # No update, send heartbeat/current state
                await websocket.send_json({
                    "type": "heartbeat",
                    "status": job.status,
                    "progress": job.progress,
                })

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for analysis {analysis_id}")
    except Exception as e:
        logger.exception(f"WebSocket error for analysis {analysis_id}")
        try:
            await websocket.send_json({
                "type": "error",
                "error": str(e),
            })
        except:
            pass
    finally:
        logger.info(f"WebSocket closing for analysis {analysis_id}")
```
  </action>
  <verify>
```bash
cd /Users/ajcolubiale/projects/cheddar-fpl-sage
python -m py_compile backend/routers/analyze.py

# Verify WebSocket endpoint exists
PYTHONPATH=src:backend python -c "
from backend.routers.analyze import router
ws_routes = [r for r in router.routes if hasattr(r, 'path') and 'stream' in r.path]
print(f'WebSocket routes: {[r.path for r in ws_routes]}')
"
```
  </verify>
  <done>
- WebSocket endpoint added at /{analysis_id}/stream
- Handles connect, progress streaming, complete/error states
- Graceful disconnect handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance engine service with async progress notifications</name>
  <files>
    backend/services/engine_service.py
  </files>
  <action>
**Update backend/services/engine_service.py** to improve progress notification:

Add import at top:
```python
from typing import Dict, Optional, Any, Callable, List
import asyncio
```

Update the EngineService class with better progress tracking:

```python
class EngineService:
    """
    Service layer that invokes the existing FPL Sage decision engine.
    Manages analysis jobs and provides progress callbacks.
    """

    def __init__(self):
        self._jobs: Dict[str, AnalysisJob] = {}  # In-memory job storage for MVP
        self._progress_callbacks: Dict[str, List[Callable]] = {}

    def create_analysis(self, team_id: int, gameweek: Optional[int] = None) -> AnalysisJob:
        """Create a new analysis job."""
        analysis_id = str(uuid.uuid4())[:8]  # Short ID for readability
        job = AnalysisJob(analysis_id, team_id, gameweek)
        self._jobs[analysis_id] = job
        self._progress_callbacks[analysis_id] = []
        return job

    def get_job(self, analysis_id: str) -> Optional[AnalysisJob]:
        """Get job by ID."""
        return self._jobs.get(analysis_id)

    def register_progress_callback(self, analysis_id: str, callback: Callable[[float, str], None]):
        """
        Register a callback for progress updates.

        Callback signature: (progress: float, phase: str) -> None
        """
        if analysis_id not in self._progress_callbacks:
            self._progress_callbacks[analysis_id] = []
        self._progress_callbacks[analysis_id].append(callback)
        logger.debug(f"Registered progress callback for {analysis_id}")

    def _notify_progress(self, analysis_id: str, progress: float, phase: str):
        """Notify all registered callbacks of progress."""
        job = self._jobs.get(analysis_id)
        if job:
            job.progress = progress
            job.phase = phase

        callbacks = self._progress_callbacks.get(analysis_id, [])
        for callback in callbacks:
            try:
                callback(progress, phase)
            except Exception as e:
                logger.warning(f"Progress callback failed: {e}")

    def _cleanup_job(self, analysis_id: str):
        """Clean up callbacks after job completes (keeps job for retrieval)."""
        if analysis_id in self._progress_callbacks:
            del self._progress_callbacks[analysis_id]

    async def run_analysis(self, analysis_id: str) -> Dict[str, Any]:
        """
        Run the analysis for a given job.
        This wraps the existing FPLSageIntegration.run_full_analysis().
        """
        job = self._jobs.get(analysis_id)
        if not job:
            raise ValueError(f"Job {analysis_id} not found")

        job.status = "running"
        self._notify_progress(analysis_id, 0, "initializing")

        try:
            # Create integration with team ID
            sage = FPLSageIntegration(team_id=job.team_id)

            # Progress phases (simulated for now, will wire up to engine later)
            self._notify_progress(analysis_id, 10, "loading_config")
            await asyncio.sleep(0.1)  # Yield to event loop

            self._notify_progress(analysis_id, 25, "collecting_data")
            await asyncio.sleep(0.1)

            self._notify_progress(analysis_id, 50, "analyzing_squad")

            # Run the actual analysis
            results = await sage.run_full_analysis(save_data=False)

            self._notify_progress(analysis_id, 90, "formatting_results")
            await asyncio.sleep(0.1)

            self._notify_progress(analysis_id, 100, "completed")

            job.status = "completed"
            job.results = results
            job.completed_at = datetime.now(timezone.utc)

            return results

        except Exception as e:
            logger.exception(f"Analysis failed for job {analysis_id}")
            job.status = "failed"
            job.error = str(e)
            job.completed_at = datetime.now(timezone.utc)
            self._notify_progress(analysis_id, job.progress, "failed")
            raise
        finally:
            # Don't cleanup immediately - allow WebSocket to get final state
            # Cleanup will happen when job expires (not implemented yet for MVP)
            pass


# Singleton instance
engine_service = EngineService()
```
  </action>
  <verify>
```bash
cd /Users/ajcolubiale/projects/cheddar-fpl-sage
python -m py_compile backend/services/engine_service.py

PYTHONPATH=src:backend python -c "
from backend.services.engine_service import engine_service, EngineService

# Test callback registration
def test_callback(progress, phase):
    print(f'Progress: {progress}%, Phase: {phase}')

job = engine_service.create_analysis(12345)
engine_service.register_progress_callback(job.analysis_id, test_callback)
engine_service._notify_progress(job.analysis_id, 50, 'testing')
print('Callback test passed')
"
```
  </verify>
  <done>
- EngineService has register_progress_callback method
- Progress notifications work with multiple callbacks
- Callbacks cleaned up after job completes
  </done>
</task>

<task type="auto">
  <name>Task 3: Add WebSocket tests</name>
  <files>
    tests/tests_new/test_websocket_progress.py
  </files>
  <action>
**Create tests/tests_new/test_websocket_progress.py:**

```python
"""
Tests for WebSocket progress streaming.
"""
import pytest
from unittest.mock import patch, MagicMock, AsyncMock
from fastapi.testclient import TestClient
import sys
import os
import json

# Add paths
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'backend'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'src'))

from backend.main import app
from backend.services.engine_service import engine_service


@pytest.fixture
def client():
    """Create test client."""
    return TestClient(app)


class TestWebSocketEndpoint:
    """Tests for WebSocket progress streaming."""

    def test_websocket_connect_valid_job(self, client):
        """WebSocket connects successfully for existing job."""
        # Create a job first
        response = client.post("/api/v1/analyze", json={"team_id": 12345})
        analysis_id = response.json()["analysis_id"]

        # Connect WebSocket
        with client.websocket_connect(f"/api/v1/analyze/{analysis_id}/stream") as ws:
            # Should receive initial progress message
            data = ws.receive_json()
            assert data["type"] in ["progress", "heartbeat", "complete"]

    def test_websocket_connect_invalid_job(self, client):
        """WebSocket returns error for non-existent job."""
        with client.websocket_connect("/api/v1/analyze/nonexistent/stream") as ws:
            data = ws.receive_json()
            assert data["type"] == "error"
            assert data["code"] == "ANALYSIS_NOT_FOUND"

    def test_websocket_receives_progress_updates(self, client):
        """WebSocket receives progress updates during analysis."""
        # Create a job
        response = client.post("/api/v1/analyze", json={"team_id": 12345})
        analysis_id = response.json()["analysis_id"]

        # Manually trigger progress notification
        with client.websocket_connect(f"/api/v1/analyze/{analysis_id}/stream") as ws:
            # Receive initial state
            initial = ws.receive_json()
            assert initial["type"] in ["progress", "heartbeat"]

            # Simulate progress update
            engine_service._notify_progress(analysis_id, 50, "testing_phase")

            # Should receive progress (or heartbeat)
            data = ws.receive_json()
            # Note: Due to timing, might get heartbeat instead of exact progress
            assert data["type"] in ["progress", "heartbeat"]

    def test_websocket_message_format(self, client):
        """WebSocket messages have correct format."""
        response = client.post("/api/v1/analyze", json={"team_id": 12345})
        analysis_id = response.json()["analysis_id"]

        with client.websocket_connect(f"/api/v1/analyze/{analysis_id}/stream") as ws:
            data = ws.receive_json()

            # Verify message structure
            assert "type" in data
            if data["type"] == "progress":
                assert "progress" in data
                assert "phase" in data
            elif data["type"] == "heartbeat":
                assert "status" in data
            elif data["type"] == "complete":
                assert "results" in data
            elif data["type"] == "error":
                assert "error" in data


class TestProgressCallbacks:
    """Tests for progress callback mechanism."""

    def test_register_callback(self):
        """Can register progress callback."""
        job = engine_service.create_analysis(99999)

        received = []
        def callback(progress, phase):
            received.append((progress, phase))

        engine_service.register_progress_callback(job.analysis_id, callback)
        engine_service._notify_progress(job.analysis_id, 50, "test")

        assert len(received) == 1
        assert received[0] == (50, "test")

    def test_multiple_callbacks(self):
        """Multiple callbacks all receive updates."""
        job = engine_service.create_analysis(99998)

        received1 = []
        received2 = []

        engine_service.register_progress_callback(
            job.analysis_id,
            lambda p, ph: received1.append((p, ph))
        )
        engine_service.register_progress_callback(
            job.analysis_id,
            lambda p, ph: received2.append((p, ph))
        )

        engine_service._notify_progress(job.analysis_id, 75, "multi_test")

        assert len(received1) == 1
        assert len(received2) == 1
        assert received1[0] == received2[0]

    def test_callback_error_doesnt_break_others(self):
        """Failing callback doesn't prevent other callbacks."""
        job = engine_service.create_analysis(99997)

        received = []

        def failing_callback(p, ph):
            raise Exception("Intentional test failure")

        def working_callback(p, ph):
            received.append((p, ph))

        engine_service.register_progress_callback(job.analysis_id, failing_callback)
        engine_service.register_progress_callback(job.analysis_id, working_callback)

        # Should not raise, working callback should still work
        engine_service._notify_progress(job.analysis_id, 25, "error_test")

        assert len(received) == 1
```
  </action>
  <verify>
```bash
cd /Users/ajcolubiale/projects/cheddar-fpl-sage

# Run WebSocket tests
PYTHONPATH=src:backend python -m pytest tests/tests_new/test_websocket_progress.py -v
```
  </verify>
  <done>
- test_websocket_progress.py has 7+ test cases
- Tests WebSocket connect, progress updates, message format
- Tests callback registration and error handling
- All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd /Users/ajcolubiale/projects/cheddar-fpl-sage

# 1. Verify WebSocket endpoint in routes
PYTHONPATH=src:backend python -c "
from backend.main import app
ws_routes = [r for r in app.routes if hasattr(r, 'path') and 'stream' in str(r.path)]
print(f'WebSocket routes found: {len(ws_routes)}')
"

# 2. Run all WebSocket tests
PYTHONPATH=src:backend python -m pytest tests/tests_new/test_websocket_progress.py -v

# 3. Run full API test suite
PYTHONPATH=src:backend python -m pytest tests/tests_new/test_api_endpoints.py tests/tests_new/test_websocket_progress.py -v
```
</verification>

<success_criteria>
- WebSocket endpoint at /api/v1/analyze/{id}/stream
- Progress updates sent as JSON with type, progress, phase
- Graceful handling of disconnects and errors
- 7+ WebSocket tests pass
- Callback mechanism works with multiple listeners
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-api/02-03-SUMMARY.md`
</output>
