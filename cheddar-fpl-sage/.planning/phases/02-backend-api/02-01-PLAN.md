---
phase: 02-backend-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/__init__.py
  - backend/main.py
  - backend/config.py
  - backend/models/__init__.py
  - backend/models/api_models.py
  - backend/services/__init__.py
  - backend/services/engine_service.py
  - src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py
  - tests/tests_new/test_manual_transfers_applied.py
autonomous: true

must_haves:
  truths:
    - "FastAPI server starts without errors"
    - "Engine service can invoke existing decision framework"
    - "Manual transfers entered by user are applied before recommendations generated"
    - "API response models validate correctly with Pydantic"
  artifacts:
    - path: "backend/main.py"
      provides: "FastAPI application entry point"
      contains: "FastAPI()"
    - path: "backend/services/engine_service.py"
      provides: "Bridge between API and CLI engine"
      contains: "EnhancedDecisionFramework"
    - path: "backend/models/api_models.py"
      provides: "Pydantic models for API requests/responses"
      contains: "AnalyzeRequest"
    - path: "tests/tests_new/test_manual_transfers_applied.py"
      provides: "Tests for manual transfer bug fix"
      min_lines: 50
  key_links:
    - from: "backend/services/engine_service.py"
      to: "src/cheddar_fpl_sage/analysis/fpl_sage_integration.py"
      via: "import FPLSageIntegration and call run_full_analysis"
      pattern: "FPLSageIntegration"
    - from: "backend/services/engine_service.py"
      to: "src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py"
      via: "manual transfers applied before recommend_transfers"
      pattern: "apply_manual_transfers"
---

<objective>
Create FastAPI project foundation and fix critical manual transfers bug.

Purpose: Establish the backend structure that will wrap the existing CLI decision engine, and fix the bug where manual transfers are not applied before generating recommendations.

Output:
- /backend directory with FastAPI app structure
- Engine service that bridges API to existing decision framework
- API models for request/response validation
- Bug fix for manual transfers not being applied
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
@src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py
@src/cheddar_fpl_sage/analysis/fpl_sage_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI project structure</name>
  <files>
    backend/__init__.py
    backend/main.py
    backend/config.py
    backend/models/__init__.py
    backend/models/api_models.py
    backend/services/__init__.py
  </files>
  <action>
Create /backend directory at project root with the following structure:

```
backend/
  __init__.py         # Package marker
  main.py             # FastAPI app with health check endpoint
  config.py           # Settings using pydantic-settings (environment variables)
  models/
    __init__.py
    api_models.py     # Pydantic models for API
  services/
    __init__.py
```

**backend/main.py:**
- Create FastAPI app with title "FPL Sage API", version "1.0.0"
- Add GET /health endpoint returning {"status": "healthy", "version": "1.0.0"}
- Add CORS middleware allowing all origins for development (will restrict in production)
- Configure lifespan context manager for startup/shutdown events

**backend/config.py:**
- Use pydantic-settings BaseSettings for configuration
- Define: REDIS_URL (default: redis://localhost:6379), DEBUG (default: False), API_V1_PREFIX (default: /api/v1)
- Load from environment variables with FPL_SAGE_ prefix

**backend/models/api_models.py:**
- AnalyzeRequest: team_id (int, required), gameweek (Optional[int], defaults to current)
- AnalyzeResponse: analysis_id (str), status (Literal["queued", "running", "completed", "failed"]), created_at (datetime)
- AnalysisStatus: status, progress (Optional[float] 0-100), phase (Optional[str]), results (Optional[dict]), error (Optional[str])
- ErrorResponse: error (str), detail (Optional[str]), code (str like "RATE_LIMITED", "INVALID_TEAM_ID")

Do NOT add FastAPI to requirements.txt yet - it will be added to backend/requirements.txt in a later task.
  </action>
  <verify>
```bash
# Verify structure exists
ls -la backend/
ls -la backend/models/
ls -la backend/services/

# Verify Python syntax
python -m py_compile backend/main.py
python -m py_compile backend/config.py
python -m py_compile backend/models/api_models.py
```
  </verify>
  <done>
- backend/ directory exists with main.py, config.py
- backend/models/api_models.py contains AnalyzeRequest, AnalyzeResponse, AnalysisStatus, ErrorResponse
- All Python files pass syntax check
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix manual transfers bug</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py
    src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
    tests/tests_new/test_manual_transfers_applied.py
  </files>
  <action>
**Bug Description:** When user enters manual transfers they've already made, the system still recommends those same transfers instead of applying them to the squad state first.

**Root Cause:** The apply_manual_transfers() method exists in TransferAdvisor and is called in analyze_chip_decision(), BUT recommend_transfers() can be called from code paths where apply_manual_transfers() was NOT invoked first.

**Fix Implementation:**

1. **In transfer_advisor.py recommend_transfers() method, add defensive auto-apply at start:**

   At the beginning of recommend_transfers(), before any recommendation logic:
   ```python
   # Check if manual transfers exist but haven't been applied yet
   if self.manual_overrides and self.manual_overrides.planned_transfers:
       out_player_names = {t.out_name for t in self.manual_overrides.planned_transfers}
       current_player_names = {p.name for p in self.current_squad}

       # If any 'out' players still in squad, they weren't applied
       unapplied = out_player_names & current_player_names
       if unapplied:
           logger.warning(f"Auto-applying {len(unapplied)} manual transfers that were not yet applied: {unapplied}")
           self.apply_manual_transfers()
   ```

2. **In enhanced_decision_framework.py _recommend_transfers() method:**

   Ensure apply_manual_transfers() is called before recommend_transfers():
   - Find the _recommend_transfers method
   - Before calling self.transfer_advisor.recommend_transfers(), add:
     ```python
     # Ensure manual transfers are applied before generating recommendations
     if self.transfer_advisor.manual_overrides:
         self.transfer_advisor.apply_manual_transfers()
     ```

3. **Create test file tests/tests_new/test_manual_transfers_applied.py:**

   ```python
   """Tests verifying manual transfers are applied before recommendations."""
   import pytest
   from unittest.mock import MagicMock, patch

   # Test cases:
   # 1. test_manual_transfer_out_player_not_recommended - verify out player excluded from recommendations
   # 2. test_manual_transfer_in_player_in_squad - verify in player appears in squad after apply
   # 3. test_recommend_transfers_auto_applies_unapplied - verify defensive check in recommend_transfers
   # 4. test_apply_manual_transfers_modifies_squad - verify squad state changes correctly
   ```

   Use mock fixtures for player data (no FPL API calls needed).
  </action>
  <verify>
```bash
# Run specific tests
cd /Users/ajcolubiale/projects/cheddar-fpl-sage
python -m pytest tests/tests_new/test_manual_transfers_applied.py -v

# Run all transfer-related tests to ensure no regression
python -m pytest tests/tests_new/ -k "transfer" -v
```
  </verify>
  <done>
- test_manual_transfers_applied.py passes with 3+ test cases
- recommend_transfers() self-applies manual transfers if they haven't been applied
- No regression in existing transfer tests
  </done>
</task>

<task type="auto">
  <name>Task 3: Create engine service bridge</name>
  <files>
    backend/services/engine_service.py
    backend/requirements.txt
  </files>
  <action>
**Create backend/services/engine_service.py:**

```python
"""
Engine service - bridges FastAPI to existing CLI decision framework.
"""
import asyncio
import logging
from typing import Dict, Optional, Any, Callable
from datetime import datetime, timezone
import uuid

# Import existing engine
from cheddar_fpl_sage.analysis.fpl_sage_integration import FPLSageIntegration
from cheddar_fpl_sage.analysis.enhanced_decision_framework import DecisionOutput

logger = logging.getLogger(__name__)

class AnalysisJob:
    """Represents a running or completed analysis job."""
    def __init__(self, analysis_id: str, team_id: int, gameweek: Optional[int] = None):
        self.analysis_id = analysis_id
        self.team_id = team_id
        self.gameweek = gameweek
        self.status = "queued"
        self.progress = 0.0
        self.phase = None
        self.results: Optional[Dict] = None
        self.error: Optional[str] = None
        self.created_at = datetime.now(timezone.utc)
        self.completed_at: Optional[datetime] = None

class EngineService:
    """
    Service layer that invokes the existing FPL Sage decision engine.
    Manages analysis jobs and provides progress callbacks.
    """

    def __init__(self):
        self._jobs: Dict[str, AnalysisJob] = {}  # In-memory job storage for MVP
        self._progress_callbacks: Dict[str, list[Callable]] = {}

    def create_analysis(self, team_id: int, gameweek: Optional[int] = None) -> AnalysisJob:
        """Create a new analysis job."""
        analysis_id = str(uuid.uuid4())[:8]  # Short ID for readability
        job = AnalysisJob(analysis_id, team_id, gameweek)
        self._jobs[analysis_id] = job
        return job

    def get_job(self, analysis_id: str) -> Optional[AnalysisJob]:
        """Get job by ID."""
        return self._jobs.get(analysis_id)

    def register_progress_callback(self, analysis_id: str, callback: Callable):
        """Register a callback for progress updates."""
        if analysis_id not in self._progress_callbacks:
            self._progress_callbacks[analysis_id] = []
        self._progress_callbacks[analysis_id].append(callback)

    def _notify_progress(self, analysis_id: str, progress: float, phase: str):
        """Notify all registered callbacks of progress."""
        job = self._jobs.get(analysis_id)
        if job:
            job.progress = progress
            job.phase = phase
        for callback in self._progress_callbacks.get(analysis_id, []):
            try:
                callback(progress, phase)
            except Exception as e:
                logger.warning(f"Progress callback failed: {e}")

    async def run_analysis(self, analysis_id: str) -> Dict[str, Any]:
        """
        Run the analysis for a given job.
        This wraps the existing FPLSageIntegration.run_full_analysis().
        """
        job = self._jobs.get(analysis_id)
        if not job:
            raise ValueError(f"Job {analysis_id} not found")

        job.status = "running"
        self._notify_progress(analysis_id, 0, "initializing")

        try:
            # Create integration with team ID
            sage = FPLSageIntegration(team_id=job.team_id)

            # TODO: In future, wire up progress callbacks to engine
            self._notify_progress(analysis_id, 25, "collecting_data")

            # Run the actual analysis
            results = await sage.run_full_analysis(save_data=False)

            self._notify_progress(analysis_id, 100, "completed")

            job.status = "completed"
            job.results = results
            job.completed_at = datetime.now(timezone.utc)

            return results

        except Exception as e:
            logger.exception(f"Analysis failed for job {analysis_id}")
            job.status = "failed"
            job.error = str(e)
            job.completed_at = datetime.now(timezone.utc)
            raise

# Singleton instance
engine_service = EngineService()
```

**Create backend/requirements.txt:**
```
# FastAPI Backend Requirements
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
pydantic>=2.5.0
pydantic-settings>=2.1.0

# Already in main project but needed for backend
aiohttp>=3.9.0
redis>=5.0.0
```

**Update backend/__init__.py:**
```python
"""FPL Sage Backend API"""
from .services.engine_service import engine_service, EngineService, AnalysisJob

__all__ = ["engine_service", "EngineService", "AnalysisJob"]
```
  </action>
  <verify>
```bash
# Verify imports work (from project root)
cd /Users/ajcolubiale/projects/cheddar-fpl-sage
PYTHONPATH=src:backend python -c "from backend.services.engine_service import EngineService; print('Import OK')"

# Verify requirements.txt is valid
pip install --dry-run -r backend/requirements.txt
```
  </verify>
  <done>
- backend/services/engine_service.py exists with EngineService class
- engine_service singleton is importable
- backend/requirements.txt lists fastapi, uvicorn, pydantic dependencies
- EngineService can import FPLSageIntegration from existing codebase
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full verification
cd /Users/ajcolubiale/projects/cheddar-fpl-sage

# 1. Project structure
ls -la backend/
ls -la backend/models/
ls -la backend/services/

# 2. Python syntax validation
python -m py_compile backend/main.py
python -m py_compile backend/config.py
python -m py_compile backend/models/api_models.py
python -m py_compile backend/services/engine_service.py

# 3. Import chain works
PYTHONPATH=src:backend python -c "
from backend.main import app
from backend.services.engine_service import engine_service
from backend.models.api_models import AnalyzeRequest, AnalyzeResponse
print('All imports successful')
"

# 4. Bug fix tests pass
python -m pytest tests/tests_new/test_manual_transfers_applied.py -v
```
</verification>

<success_criteria>
- /backend directory created with FastAPI project structure
- backend/main.py has health check endpoint
- backend/models/api_models.py has request/response models
- backend/services/engine_service.py bridges to existing decision framework
- Manual transfers bug fixed and tested
- All Python files pass syntax check
- All imports work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-api/02-01-SUMMARY.md`
</output>
