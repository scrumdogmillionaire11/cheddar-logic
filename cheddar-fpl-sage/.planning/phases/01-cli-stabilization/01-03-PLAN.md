---
phase: 01-cli-stabilization
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/cheddar_fpl_sage/analysis/decision_framework/config_models.py
  - src/cheddar_fpl_sage/utils/sprint3_5_config_manager.py
  - src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
autonomous: true

must_haves:
  truths:
    - "Config files validate on load with clear error messages"
    - "Config round-trips cleanly (write -> read -> same data)"
    - "Invalid config fields produce Pydantic ValidationError with field name"
    - "Existing config files load without errors"
  artifacts:
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/config_models.py"
      provides: "Pydantic models for config validation"
      contains: "class TeamConfig"
    - path: "src/cheddar_fpl_sage/utils/sprint3_5_config_manager.py"
      provides: "Updated config manager with validation"
      contains: "TeamConfig.model_validate"
  key_links:
    - from: "sprint3_5_config_manager.py"
      to: "config_models.py"
      via: "Pydantic validation"
      pattern: "TeamConfig"
---

<objective>
Add Pydantic schema validation to config management, fixing the serialization fragility issues.

Purpose: Ensure config round-trips cleanly (write -> read -> same data). Replace manual dict normalization with schema validation that provides clear error messages. Existing users' config files must continue to work.

Output: Pydantic config models + updated Sprint35ConfigManager that validates on load/save.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cli-stabilization/01-RESEARCH.md
@.planning/phases/01-cli-stabilization/01-01-SUMMARY.md
@src/cheddar_fpl_sage/utils/sprint3_5_config_manager.py
@config/team_config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic config models</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/config_models.py
    src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
  </files>
  <action>
Create Pydantic models that match the existing config structure. Analyze `config/team_config.json` for actual field names and types.

Create `config_models.py`:
```python
"""
Pydantic models for FPL Sage configuration.
Provides schema validation and serialization for team_config.json.
"""
from pydantic import BaseModel, Field, field_validator, model_validator
from typing import Optional, Dict, Any, Literal
from datetime import datetime

class ChipStatus(BaseModel):
    """Status of a single chip."""
    available: bool = True
    played_gw: Optional[int] = None

    class Config:
        extra = 'ignore'  # Ignore unknown fields for forward compatibility

class ManualTransfer(BaseModel):
    """A single manual transfer specification."""
    player_out: str
    player_in: str
    player_in_id: Optional[int] = None
    player_in_team: Optional[str] = None
    player_in_position: Optional[str] = None
    player_in_price: Optional[float] = None

class InjuryOverride(BaseModel):
    """Manual injury status override."""
    player_name: str
    status: Literal["FIT", "DOUBT", "OUT", "SUSPENDED"] = "FIT"
    reason: Optional[str] = None

class ChipWindow(BaseModel):
    """Chip timing window configuration."""
    start_gw: int
    end_gw: int
    chip: str
    reason: Optional[str] = None

class ChipPolicy(BaseModel):
    """Chip usage policy configuration."""
    chip_windows: list[ChipWindow] = Field(default_factory=list)
    bench_boost_threshold: float = 15.0
    triple_captain_threshold: float = 12.0

class TeamConfig(BaseModel):
    """
    Complete team configuration.

    Validates all fields on construction. Provides model_dump() for
    serialization and model_validate() for deserialization.
    """
    # Core identification
    manager_id: int
    manager_name: str = "Unknown Manager"

    # Analysis settings
    risk_posture: Literal["CHASE", "DEFEND", "BALANCED"] = "BALANCED"

    # Chip management
    manual_chip_status: Dict[str, ChipStatus] = Field(default_factory=dict)
    chip_policy: ChipPolicy = Field(default_factory=ChipPolicy)

    # Override settings
    manual_free_transfers: Optional[int] = None
    manual_transfers: list[ManualTransfer] = Field(default_factory=list)
    injury_overrides: list[InjuryOverride] = Field(default_factory=list)

    # Metadata
    last_updated: Optional[datetime] = None
    config_version: str = "1.0"

    class Config:
        extra = 'ignore'  # Forward compatibility: ignore unknown fields
        validate_assignment = True  # Validate on attribute changes

    @field_validator('manual_chip_status', mode='before')
    @classmethod
    def normalize_chip_status(cls, v):
        """Handle legacy formats: string JSON, empty values."""
        if isinstance(v, str):
            import json
            try:
                v = json.loads(v)
            except json.JSONDecodeError:
                v = {}
        if not isinstance(v, dict):
            v = {}
        # Ensure all chips have status
        for chip in ["Wildcard", "Free Hit", "Bench Boost", "Triple Captain"]:
            if chip not in v:
                v[chip] = {"available": True, "played_gw": None}
            elif isinstance(v[chip], bool):
                # Handle legacy format: chip: True/False
                v[chip] = {"available": v[chip], "played_gw": None}
        return v

    @field_validator('manual_transfers', mode='before')
    @classmethod
    def normalize_transfers(cls, v):
        """Handle legacy formats for manual transfers."""
        if isinstance(v, str):
            import json
            try:
                v = json.loads(v)
            except json.JSONDecodeError:
                v = []
        if not isinstance(v, list):
            v = []
        return v

    @field_validator('chip_policy', mode='before')
    @classmethod
    def normalize_chip_policy(cls, v):
        """Handle missing or malformed chip policy."""
        if isinstance(v, str):
            import json
            try:
                v = json.loads(v)
            except json.JSONDecodeError:
                v = {}
        if not isinstance(v, dict):
            v = {}
        return v

    @model_validator(mode='after')
    def set_update_time(self):
        """Auto-set last_updated on validation."""
        if self.last_updated is None:
            object.__setattr__(self, 'last_updated', datetime.now())
        return self
```

Update `decision_framework/__init__.py` to export config models:
```python
from .config_models import TeamConfig, ChipStatus, ManualTransfer, InjuryOverride, ChipPolicy, ChipWindow
```

WHY these validators:
- `normalize_chip_status`: Existing configs have stringified JSON or boolean values
- `normalize_transfers`: Same issue - can be string, list, or missing
- `extra = 'ignore'`: Don't break on unknown fields (forward compatibility)
- `validate_assignment`: Catch invalid changes immediately
  </action>
  <verify>
```bash
python -c "
from cheddar_fpl_sage.analysis.decision_framework import TeamConfig
import json

# Test basic construction
config = TeamConfig(manager_id=123, manager_name='Test Manager')
print(f'Created config: {config.manager_id}')

# Test serialization round-trip
json_str = config.model_dump_json(indent=2)
reloaded = TeamConfig.model_validate_json(json_str)
assert reloaded.manager_id == config.manager_id
print('Round-trip OK')

# Test legacy format handling
legacy = {'manager_id': 456, 'manual_chip_status': '{\"Wildcard\": true}'}
parsed = TeamConfig.model_validate(legacy)
assert parsed.manual_chip_status['Wildcard'].available == True
print('Legacy format handling OK')
"
```
  </verify>
  <done>TeamConfig Pydantic model validates all fields. Round-trips cleanly. Handles legacy formats (stringified JSON, boolean chips).</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Pydantic validation into config manager</name>
  <files>
    src/cheddar_fpl_sage/utils/sprint3_5_config_manager.py
  </files>
  <action>
Update Sprint35ConfigManager to use Pydantic validation while preserving the existing API.

Modify `sprint3_5_config_manager.py`:

1. Add import at top:
```python
from cheddar_fpl_sage.analysis.decision_framework import TeamConfig, ConfigurationError
```

2. Update `_load_from_disk()` to use Pydantic:
```python
def _load_from_disk(self) -> Dict[str, Any]:
    """Load and validate config from disk."""
    if not self.config_file.exists():
        # Return default config
        default = TeamConfig(manager_id=0, manager_name="Unknown")
        return default.model_dump()

    try:
        with open(self.config_file, 'r') as f:
            raw_content = f.read()

        # Handle double-encoded JSON (legacy issue)
        try:
            raw = json.loads(raw_content)
            if isinstance(raw, str):
                raw = json.loads(raw)
        except json.JSONDecodeError as e:
            raise ConfigurationError(f"Invalid JSON in config file: {e}")

        # Validate with Pydantic
        validated = TeamConfig.model_validate(raw)
        return validated.model_dump()

    except Exception as e:
        if isinstance(e, ConfigurationError):
            raise
        logger.warning(f"Config load failed, using defaults: {e}")
        default = TeamConfig(manager_id=0, manager_name="Unknown")
        return default.model_dump()
```

3. Update `_save_to_disk()` to validate before write:
```python
def _save_to_disk(self, config: Dict[str, Any]) -> None:
    """Validate and save config to disk atomically."""
    # Validate before writing
    try:
        validated = TeamConfig.model_validate(config)
    except Exception as e:
        raise ConfigurationError(f"Cannot save invalid config: {e}")

    # Atomic write (existing logic)
    temp_file = self.config_file.with_suffix('.tmp')
    try:
        with open(temp_file, 'w') as f:
            f.write(validated.model_dump_json(indent=2))
        temp_file.replace(self.config_file)
    except Exception as e:
        if temp_file.exists():
            temp_file.unlink()
        raise ConfigurationError(f"Failed to write config: {e}")
```

4. Remove manual normalization methods that Pydantic now handles:
- `_ensure_dict()` - Pydantic validators handle this
- `_normalize_chip_status()` - Pydantic field_validator handles this
- Keep atomic write logic (temp file -> rename)

5. Update any `except Exception:` in config methods to use `ConfigurationError`:
```python
except json.JSONDecodeError as e:
    raise ConfigurationError(f"Invalid JSON: {e}") from e
except FileNotFoundError:
    # Expected, use defaults
    pass
except PermissionError as e:
    raise ConfigurationError(f"Cannot access config file: {e}") from e
```

CRITICAL:
- Keep the same public API (get_config(), update_config(), etc.)
- The internal representation is still Dict[str, Any] for compatibility
- Pydantic validates at boundaries (load/save), not on every access
  </action>
  <verify>
```bash
# Test with existing config file
python -c "
from cheddar_fpl_sage.utils.sprint3_5_config_manager import Sprint35ConfigManager
import json

# Load existing config
manager = Sprint35ConfigManager()
config = manager.get_config(force_reload=True)
print(f'Loaded config for manager: {config.get(\"manager_name\", \"Unknown\")}')

# Test round-trip
manager._save_to_disk(config)
reloaded = manager.get_config(force_reload=True)
print(f'Round-trip manager_id: {reloaded.get(\"manager_id\")} == {config.get(\"manager_id\")}')
print('Config manager validation OK')
"

# Verify invalid config raises proper error
python -c "
from cheddar_fpl_sage.analysis.decision_framework import TeamConfig, ConfigurationError
try:
    TeamConfig(manager_id='not_an_int')
except Exception as e:
    print(f'Validation error caught: {type(e).__name__}')
"
```
  </verify>
  <done>Sprint35ConfigManager uses Pydantic validation on load/save. Invalid configs raise ConfigurationError with field names. Existing config files load successfully.</done>
</task>

<task type="auto">
  <name>Task 3: Add config validation tests</name>
  <files>
    tests/tests_new/test_config_validation.py
  </files>
  <action>
Create targeted tests for config validation edge cases identified in CONCERNS.md.

Create `tests/tests_new/test_config_validation.py`:
```python
"""
Tests for config serialization and validation.

Covers edge cases identified in CONCERNS.md:
- Stringified JSON in config fields
- Malformed JSON
- Missing required fields
- Config corruption recovery
- Round-trip consistency
"""
import pytest
import json
import tempfile
from pathlib import Path

from cheddar_fpl_sage.analysis.decision_framework import (
    TeamConfig, ChipStatus, ConfigurationError
)
from cheddar_fpl_sage.utils.sprint3_5_config_manager import Sprint35ConfigManager


class TestTeamConfigValidation:
    """Tests for TeamConfig Pydantic model."""

    def test_basic_config_creation(self):
        """Config creates with required fields."""
        config = TeamConfig(manager_id=123, manager_name="Test")
        assert config.manager_id == 123
        assert config.manager_name == "Test"
        assert config.risk_posture == "BALANCED"  # default

    def test_invalid_risk_posture_rejected(self):
        """Invalid risk posture raises validation error."""
        with pytest.raises(Exception) as exc_info:
            TeamConfig(manager_id=123, risk_posture="YOLO")
        assert "risk_posture" in str(exc_info.value).lower()

    def test_stringified_json_chip_status(self):
        """Handles legacy stringified JSON in chip status."""
        legacy_data = {
            "manager_id": 123,
            "manual_chip_status": '{"Wildcard": {"available": false, "played_gw": 10}}'
        }
        config = TeamConfig.model_validate(legacy_data)
        assert config.manual_chip_status["Wildcard"].available == False
        assert config.manual_chip_status["Wildcard"].played_gw == 10

    def test_boolean_chip_status_legacy(self):
        """Handles legacy boolean chip status."""
        legacy_data = {
            "manager_id": 123,
            "manual_chip_status": {"Wildcard": True, "Free Hit": False}
        }
        config = TeamConfig.model_validate(legacy_data)
        assert config.manual_chip_status["Wildcard"].available == True
        assert config.manual_chip_status["Free Hit"].available == False

    def test_missing_chips_get_defaults(self):
        """Missing chips in status get default values."""
        config = TeamConfig(manager_id=123, manual_chip_status={})
        assert "Wildcard" in config.manual_chip_status
        assert "Free Hit" in config.manual_chip_status
        assert config.manual_chip_status["Bench Boost"].available == True

    def test_round_trip_consistency(self):
        """Config survives JSON round-trip unchanged."""
        original = TeamConfig(
            manager_id=456,
            manager_name="Round Trip Test",
            risk_posture="CHASE",
            manual_chip_status={"Wildcard": ChipStatus(available=False, played_gw=5)}
        )

        # Serialize and deserialize
        json_str = original.model_dump_json()
        reloaded = TeamConfig.model_validate_json(json_str)

        assert reloaded.manager_id == original.manager_id
        assert reloaded.manager_name == original.manager_name
        assert reloaded.risk_posture == original.risk_posture
        assert reloaded.manual_chip_status["Wildcard"].played_gw == 5

    def test_extra_fields_ignored(self):
        """Unknown fields don't break validation (forward compat)."""
        future_data = {
            "manager_id": 123,
            "manager_name": "Future",
            "new_field_from_v2": "should be ignored",
            "another_new_field": {"nested": "data"}
        }
        config = TeamConfig.model_validate(future_data)
        assert config.manager_id == 123
        # No error raised


class TestConfigManagerIntegration:
    """Tests for Sprint35ConfigManager with Pydantic validation."""

    @pytest.fixture
    def temp_config_dir(self, tmp_path):
        """Create temp directory for config tests."""
        return tmp_path

    def test_load_valid_config(self, temp_config_dir):
        """Valid config file loads successfully."""
        config_file = temp_config_dir / "team_config.json"
        config_file.write_text(json.dumps({
            "manager_id": 789,
            "manager_name": "Valid Test",
            "risk_posture": "DEFEND"
        }))

        manager = Sprint35ConfigManager(config_file=config_file)
        config = manager.get_config()

        assert config["manager_id"] == 789
        assert config["risk_posture"] == "DEFEND"

    def test_load_malformed_json_uses_defaults(self, temp_config_dir):
        """Malformed JSON falls back to defaults with warning."""
        config_file = temp_config_dir / "team_config.json"
        config_file.write_text("{ this is not valid json }")

        manager = Sprint35ConfigManager(config_file=config_file)
        config = manager.get_config()

        # Should get defaults, not crash
        assert "manager_id" in config

    def test_save_validates_before_write(self, temp_config_dir):
        """Invalid config data rejected on save."""
        config_file = temp_config_dir / "team_config.json"
        manager = Sprint35ConfigManager(config_file=config_file)

        # Try to save invalid config
        with pytest.raises(ConfigurationError):
            manager._save_to_disk({"manager_id": "not_an_int"})

    def test_atomic_write_preserves_on_failure(self, temp_config_dir):
        """Failed write doesn't corrupt existing config."""
        config_file = temp_config_dir / "team_config.json"
        original_content = json.dumps({"manager_id": 100, "manager_name": "Original"})
        config_file.write_text(original_content)

        manager = Sprint35ConfigManager(config_file=config_file)

        # Attempt invalid save
        try:
            manager._save_to_disk({"manager_id": "invalid"})
        except ConfigurationError:
            pass

        # Original should be preserved
        assert json.loads(config_file.read_text())["manager_id"] == 100
```

Run the new tests:
```bash
pytest tests/tests_new/test_config_validation.py -v
```
  </action>
  <verify>
```bash
pytest tests/tests_new/test_config_validation.py -v --tb=short
```
  </verify>
  <done>Config validation tests pass. Tests cover: stringified JSON, boolean legacy format, round-trip, extra fields, malformed JSON, atomic write safety.</done>
</task>

</tasks>

<verification>
Config validation complete:
```bash
# All config tests pass
pytest tests/tests_new/test_config_validation.py -v

# Existing config loads (real file test)
python -c "
from cheddar_fpl_sage.utils.sprint3_5_config_manager import Sprint35ConfigManager
manager = Sprint35ConfigManager()
config = manager.get_config(force_reload=True)
print(f'Loaded: {config.get(\"manager_name\")}')

# Round-trip test
import json
json_str = json.dumps(config)
print(f'Serializes to {len(json_str)} chars')
"

# No regression in full suite
pytest tests/ -x -q
```
</verification>

<success_criteria>
- TeamConfig Pydantic model validates all config fields
- Legacy formats (stringified JSON, boolean chips) handled gracefully
- Config round-trips without data loss
- Invalid configs raise ConfigurationError with field name
- Existing config/team_config.json loads without errors
- 10+ test cases for config validation edge cases
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-stabilization/01-03-SUMMARY.md`
</output>
