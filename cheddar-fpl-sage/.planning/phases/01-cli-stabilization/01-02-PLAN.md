---
phase: 01-cli-stabilization
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/cheddar_fpl_sage/analysis/decision_framework/chip_analyzer.py
  - src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py
  - src/cheddar_fpl_sage/analysis/decision_framework/captain_selector.py
  - src/cheddar_fpl_sage/analysis/decision_framework/output_formatter.py
  - src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
  - src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
autonomous: true

must_haves:
  truths:
    - "Chip analysis methods are in chip_analyzer.py module"
    - "Transfer recommendation methods are in transfer_advisor.py module"
    - "Captain selection methods are in captain_selector.py module"
    - "Output formatting methods are in output_formatter.py module"
    - "Manager Risk Tolerance has 3 input paths: CLI arg > Runtime prompt > team_config.json > BALANCED default"
    - "Risk posture enum validated centrally (CONSERVATIVE|BALANCED|AGGRESSIVE), modules consume only"
    - "Transfer volatility penalty multipliers: CONSERVATIVE 1.25x, BALANCED 1.0x, AGGRESSIVE 0.8x"
    - "risk_note output includes manager posture for auditability"
    - "EnhancedDecisionFramework delegates to new modules"
    - "Existing CLI workflow produces identical output"
    - "enhanced_decision_framework.py reduced from 3,681 to < 1,500 lines"
  artifacts:
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/chip_analyzer.py"
      provides: "ChipAnalyzer class"
      contains: "class ChipAnalyzer"
      min_lines: 200
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py"
      provides: "TransferAdvisor class"
      contains: "class TransferAdvisor"
      min_lines: 200
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/captain_selector.py"
      provides: "CaptainSelector class"
      contains: "class CaptainSelector"
      min_lines: 100
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/output_formatter.py"
      provides: "OutputFormatter class"
      contains: "class OutputFormatter"
      min_lines: 100
  key_links:
    - from: "enhanced_decision_framework.py"
      to: "chip_analyzer.py"
      via: "delegation"
      pattern: "self._chip_analyzer"
    - from: "enhanced_decision_framework.py"
      to: "transfer_advisor.py"
      via: "delegation"
      pattern: "self._transfer_advisor"
    - from: "enhanced_decision_framework.py"
      to: "captain_selector.py"
      via: "delegation"
      pattern: "self._captain_selector"
---

<objective>
Extract domain modules from the 3,681-line monolith `enhanced_decision_framework.py` into focused, single-responsibility modules.

Purpose: Transform fragile monolith into maintainable, testable modules. Each module handles one concern (chips, transfers, captaincy, output). The orchestrator becomes a thin coordinator.

Output: 4 new domain modules + refactored orchestrator that delegates to them. Existing workflow unchanged. Monolith reduced to < 1,500 lines.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cli-stabilization/01-RESEARCH.md
@.planning/phases/01-cli-stabilization/01-01-SUMMARY.md
@src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract ChipAnalyzer module</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/chip_analyzer.py
    src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
  </files>
  <action>
Extract all chip-related methods from EnhancedDecisionFramework into ChipAnalyzer class.

**SPECIFIC METHODS TO EXTRACT (with line numbers from enhanced_decision_framework.py):**

| Method Name | Line Start | Description |
|-------------|------------|-------------|
| `analyze_chip_decision()` | ~525 | Main chip analysis entry point |
| `_analyze_no_chip_decision()` | ~922 | No-chip scenario handling |
| `chip_expires_before_next_deadline()` | ~959 | Static method for expiry check |
| `_analyze_triple_captain_decision()` | ~873 | Triple Captain specific logic |
| `_can_activate_triple_captain()` | ~1533 | TC activation check |
| `_has_strong_captain_candidate()` | ~1054 | Captain strength evaluation |

Also extract any helper methods these call that are chip-specific (look for methods referencing "window", "chip_policy", "bench_boost").

Create `chip_analyzer.py`:
```python
"""
Chip analysis module for FPL decision framework.
Handles Bench Boost, Triple Captain, Free Hit, and Wildcard timing decisions.
"""
import logging
from typing import Optional, Dict, Any, List
from .exceptions import ChipAnalysisError, DataValidationError
from .models import ChipRecommendation
from .constants import CHIP_NAMES

logger = logging.getLogger(__name__)

class ChipAnalyzer:
    """Analyzes chip timing and usage recommendations."""

    def __init__(self, risk_posture: str = "BALANCED"):
        self.risk_posture = risk_posture

    def analyze_chip_decision(
        self,
        squad_data: Dict[str, Any],
        fixture_data: Dict[str, Any],
        projections: Dict[int, Any],
        chip_status: Dict[str, Any],
        current_gw: int,
        chip_policy: Optional[Dict[str, Any]] = None
    ) -> ChipRecommendation:
        """
        Analyze which chip (if any) to play this gameweek.

        Returns ChipRecommendation with chip type, reasoning, and confidence.
        """
        # [MOVE method body from enhanced_decision_framework.py line ~525]
        pass

    def _analyze_no_chip_decision(self, team_data: Dict, fixture_data: Dict,
                                   projections: Dict, chip_status: Dict) -> ChipRecommendation:
        # [MOVE method body from line ~922]
        pass

    @staticmethod
    def chip_expires_before_next_deadline(chip_name: str, now_gw: int, chip_policy: Dict) -> bool:
        # [MOVE method body from line ~959]
        pass

    def _analyze_triple_captain_decision(self, team_data: Dict, fixture_data: Dict,
                                          projections: Dict, chip_status: Dict) -> ChipRecommendation:
        # [MOVE method body from line ~873]
        pass

    def _can_activate_triple_captain(self, team_data: Dict, fixture_data: Dict,
                                      window_context: Dict[str, Any], projections: Dict) -> bool:
        # [MOVE method body from line ~1533]
        pass

    def _has_strong_captain_candidate(self, squad: List[Dict], fixture_data: Dict) -> bool:
        # [MOVE method body from line ~1054]
        pass
```

In enhanced_decision_framework.py:
1. Add import: `from .decision_framework import ChipAnalyzer`
2. In `__init__`, create: `self._chip_analyzer = ChipAnalyzer(risk_posture=self.risk_posture)`
3. Replace chip method bodies with delegation:
```python
def analyze_chip_decision(self, team_data, fixture_data, projections, chip_status):
    return self._chip_analyzer.analyze_chip_decision(
        squad_data=team_data,
        fixture_data=fixture_data,
        projections=projections,
        chip_status=chip_status,
        current_gw=self.current_gw,
        chip_policy=self.chip_policy
    )
```

CRITICAL: Do NOT change method signatures or return types yet. Delegation must be transparent to callers.

WHY extract:
- Chip logic is self-contained (~500-800 lines)
- Can be unit tested independently
- Separates "what chip to play" from "who to transfer"
  </action>
  <verify>
```bash
# Test that chip analysis still works through orchestrator
python -c "
from cheddar_fpl_sage.analysis.decision_framework import ChipAnalyzer
analyzer = ChipAnalyzer()
print('ChipAnalyzer instantiates OK')
"

# Smoke test existing workflow (should not break)
pytest tests/tests_new/test_orchestrator_smoke.py -x -q

# Verify delegation works - call through EnhancedDecisionFramework
python -c "
from cheddar_fpl_sage.analysis.enhanced_decision_framework import EnhancedDecisionFramework
edf = EnhancedDecisionFramework(manager_id=1, risk_posture='BALANCED')
# Check that _chip_analyzer exists (delegation instance)
assert hasattr(edf, '_chip_analyzer'), 'Delegation not set up'
print('ChipAnalyzer delegation OK')
"
```
  </verify>
  <done>ChipAnalyzer class exists with all chip methods extracted. EnhancedDecisionFramework._chip_analyzer delegates to it. Existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Extract TransferAdvisor and CaptainSelector modules</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py
    src/cheddar_fpl_sage/analysis/decision_framework/captain_selector.py
    src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
  </files>
  <action>
Extract transfer and captain methods into dedicated modules.

**TRANSFER METHODS TO EXTRACT (with line numbers):**

| Method Name | Line Start | Description |
|-------------|------------|-------------|
| `_apply_manual_transfers()` | ~429 | Apply user-specified manual transfers |
| `_assess_critical_transfer_needs()` | ~991 | Evaluate transfer urgency |
| `_analyze_difficult_transfer_situation()` | ~1116 | Handle complex transfer scenarios |
| `_analyze_multi_transfer_optimization()` | ~1143 | Optimize multiple transfers |
| `_recommend_transfers()` | ~1642 | Main transfer recommendation logic |
| `_context_allows_transfer()` | ~1890 | Check if context permits transfer |
| `_build_transfer_plan()` | ~1905 | Build complete transfer plan |

Create `transfer_advisor.py`:
```python
"""
Transfer recommendation module for FPL decision framework.
Handles transfer suggestions, manual transfers, and player evaluation.
"""
import logging
from typing import Optional, Dict, Any, List
from .exceptions import TransferValidationError, PlayerNotFoundError
from .models import TransferRecommendation
from .constants import is_manual_player, MANUAL_PLAYER_ID_START, FALLBACK_PROJECTION_PTS, FALLBACK_NEXT_3GW_PTS, FALLBACK_NEXT_5GW_PTS

logger = logging.getLogger(__name__)

class TransferAdvisor:
    """Recommends optimal transfers based on projections and constraints."""

    def __init__(self, risk_posture: str = "BALANCED", horizon_gws: int = 5):
        self.risk_posture = risk_posture
        self.horizon_gws = horizon_gws

    def recommend_transfers(
        self,
        current_squad: List[Dict],
        projections: Dict[int, Any],
        budget: float,
        free_transfers: int,
        max_transfers: int = 2
    ) -> List[TransferRecommendation]:
        """Generate transfer recommendations."""
        # [MOVE _recommend_transfers() body from line ~1642]
        pass

    def apply_manual_transfers(
        self,
        squad: List[Dict],
        manual_transfers: List[Dict]
    ) -> List[Dict]:
        """Apply user-specified manual transfers to squad."""
        # [MOVE _apply_manual_transfers() body from line ~429]
        pass

    def _assess_critical_transfer_needs(self, squad: List[Dict]) -> int:
        # [MOVE from line ~991]
        pass

    def _analyze_difficult_transfer_situation(self, team_data: Dict, fixture_data: Dict,
                                               projections: Dict, chip_status: Dict) -> Dict:
        # [MOVE from line ~1116]
        pass

    def _analyze_multi_transfer_optimization(self, team_data: Dict, fixture_data: Dict,
                                              projections: Dict, chip_status: Dict) -> Dict:
        # [MOVE from line ~1143]
        pass

    def _context_allows_transfer(self, context_mode: str, projected_gain: float) -> bool:
        # [MOVE from line ~1890]
        pass

    def _build_transfer_plan(self, ...):
        # [MOVE from line ~1905]
        pass

    def _create_fallback_projection(self, player: Dict) -> Dict:
        """
        Create conservative projection for manually added players.
        Uses constants rather than hardcoded values.
        """
        player_id = player.get('player_id', 0)
        if not is_manual_player(player_id):
            raise ValueError(f"Only call for manual players, got ID {player_id}")

        return {
            'player_id': player_id,
            'name': player.get('name', 'Manual Player'),  # Use actual name!
            'position': player.get('position', 'DEF'),
            'team': player.get('team', 'UNK'),
            'nextGW_pts': FALLBACK_PROJECTION_PTS,
            'next3GW_pts': FALLBACK_NEXT_3GW_PTS,
            'next5GW_pts': FALLBACK_NEXT_5GW_PTS,
            'is_manual': True,
        }

    def _ensure_projections(self, squad: List[Dict], projections: Dict[int, Any]) -> List[Dict]:
        """Ensure all squad members have projections, using fallback for manual players."""
        result = []
        for player in squad:
            player_id = player.get('player_id')
            if player_id in projections:
                merged = {**player, **projections[player_id]}
                result.append(merged)
            elif is_manual_player(player_id):
                fallback = self._create_fallback_projection(player)
                result.append(fallback)
            else:
                logger.warning("No projection for player %s", player_id)
                result.append(player)
        return result
```

**CAPTAIN METHODS TO EXTRACT (with line numbers):**

| Method Name | Line Start | Description |
|-------------|------------|-------------|
| `_recommend_captaincy_from_xi()` | ~346 | Recommend captain from optimized XI |
| `_recommend_captaincy()` | ~1278 | Main captain recommendation |

Create `captain_selector.py`:
```python
"""
Captain selection module for FPL decision framework.
Handles captain and vice-captain recommendations.
"""
import logging
from typing import Optional, Dict, Any, List
from .models import CaptainPick
from .constants import POSITIONS

logger = logging.getLogger(__name__)

class CaptainSelector:
    """Selects optimal captain and vice-captain."""

    def __init__(self, risk_posture: str = "BALANCED"):
        self.risk_posture = risk_posture

    def recommend_captaincy(
        self,
        starting_xi: List[Dict],
        projections: Dict[int, Any]
    ) -> CaptainPick:
        """Select captain and vice-captain from starting XI."""
        # [MOVE _recommend_captaincy() body from line ~1278]
        pass

    def recommend_captaincy_from_xi(self, optimized_xi, fixture_data: Dict,
                                     projections: Dict) -> CaptainPick:
        # [MOVE _recommend_captaincy_from_xi() body from line ~346]
        pass
```

Update enhanced_decision_framework.py:
1. Add imports for TransferAdvisor, CaptainSelector
2. Create instances in __init__:
   ```python
   self._transfer_advisor = TransferAdvisor(risk_posture=self.risk_posture)
   self._captain_selector = CaptainSelector(risk_posture=self.risk_posture)
   ```
3. Delegate method calls

IMPORTANT: Keep the manual player ID check using `is_manual_player()` from constants, NOT hardcoded 999999.
  </action>
  <verify>
```bash
python -c "
from cheddar_fpl_sage.analysis.decision_framework import TransferAdvisor, CaptainSelector
ta = TransferAdvisor()
cs = CaptainSelector()
print('TransferAdvisor and CaptainSelector instantiate OK')
"

# Verify delegation is set up
python -c "
from cheddar_fpl_sage.analysis.enhanced_decision_framework import EnhancedDecisionFramework
edf = EnhancedDecisionFramework(manager_id=1, risk_posture='BALANCED')
assert hasattr(edf, '_transfer_advisor'), 'TransferAdvisor delegation missing'
assert hasattr(edf, '_captain_selector'), 'CaptainSelector delegation missing'
print('All delegations set up OK')
"

# Full test suite
pytest tests/ -x -q --tb=short
```
  </verify>
  <done>TransferAdvisor and CaptainSelector classes exist. Manual player handling uses is_manual_player() helper. Delegation transparent to callers.</done>
</task>

<task type="auto">
  <name>Task 3: Extract OutputFormatter, finalize orchestrator, verify line reduction</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/output_formatter.py
    src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
    src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
  </files>
  <action>
Extract output formatting and finalize the module structure.

**OUTPUT METHODS TO EXTRACT (with line numbers):**

| Method Name | Line Start | Description |
|-------------|------------|-------------|
| `_finalize_decision()` | ~1500 | Finalize decision output |
| `_apply_window_context()` | ~1506 | Apply window context to decision |
| `_align_confidence_with_risk()` | ~1602 | Adjust confidence based on risk |
| `generate_decision_summary()` | ~1982 | Generate complete summary |
| `_format_timestamp()` | ~2026 | Internal timestamp formatting |

Create `output_formatter.py`:
```python
"""
Output formatting module for FPL decision framework.
Handles summary generation and presentation.
"""
import logging
from typing import Optional, Dict, Any, List
from datetime import datetime
from .models import DecisionSummary, TransferRecommendation, CaptainPick, ChipRecommendation, OptimizedXI

logger = logging.getLogger(__name__)

class OutputFormatter:
    """Formats decision results for output."""

    def generate_summary(
        self,
        manager_id: int,
        manager_name: str,
        gameweek: int,
        transfers: List[TransferRecommendation],
        captain: CaptainPick,
        chip: ChipRecommendation,
        optimized_xi: OptimizedXI,
        risk_posture: str
    ) -> DecisionSummary:
        """Generate complete decision summary."""
        return DecisionSummary(
            manager_id=manager_id,
            manager_name=manager_name,
            gameweek=gameweek,
            transfers=transfers,
            captain=captain,
            chip=chip,
            optimized_xi=optimized_xi,
            risk_posture=risk_posture
        )

    def format_markdown_report(self, summary: DecisionSummary) -> str:
        """Format summary as markdown for CLI output."""
        # [MOVE generate_decision_summary() body from line ~1982]
        pass

    def _finalize_decision(self, decision_output, chip_type, risk_posture: str):
        # [MOVE from line ~1500]
        pass

    def _apply_window_context(self, decision_output, chip_type, window_context: Dict):
        # [MOVE from line ~1506]
        pass

    def _align_confidence_with_risk(self, decision_output):
        # [MOVE from line ~1602]
        pass

    @staticmethod
    def _format_timestamp(value: Optional[str]) -> str:
        # [MOVE from line ~2026]
        pass
```

Update `decision_framework/__init__.py` with complete exports:
```python
"""
FPL Decision Framework - Modular analysis engine.

This package provides:
- ChipAnalyzer: Chip timing recommendations
- TransferAdvisor: Transfer suggestions with manual override support
- CaptainSelector: Captain and vice-captain picks
- OutputFormatter: Summary generation and formatting
- Exceptions: Domain-specific error types
- Models: Pydantic data models for decisions
- Constants: Centralized configuration values
"""

from .exceptions import (
    FPLSageError, DataValidationError, ConfigurationError,
    PlayerNotFoundError, ProjectionMissingError, ChipAnalysisError,
    TransferValidationError, FormationError
)
from .models import (
    TransferRecommendation, CaptainPick, ChipRecommendation,
    OptimizedXI, DecisionSummary
)
from .constants import (
    MANUAL_PLAYER_ID_START, is_manual_player,
    SQUAD_SIZE, STARTING_XI_SIZE, MAX_PLAYERS_PER_TEAM,
    CHIP_NAMES, POSITIONS, RISK_POSTURES,
    FALLBACK_PROJECTION_PTS, FALLBACK_NEXT_3GW_PTS, FALLBACK_NEXT_5GW_PTS
)
from .chip_analyzer import ChipAnalyzer
from .transfer_advisor import TransferAdvisor
from .captain_selector import CaptainSelector
from .output_formatter import OutputFormatter

__all__ = [
    # Classes
    'ChipAnalyzer', 'TransferAdvisor', 'CaptainSelector', 'OutputFormatter',
    # Exceptions
    'FPLSageError', 'DataValidationError', 'ConfigurationError',
    'PlayerNotFoundError', 'ProjectionMissingError', 'ChipAnalysisError',
    'TransferValidationError', 'FormationError',
    # Models
    'TransferRecommendation', 'CaptainPick', 'ChipRecommendation',
    'OptimizedXI', 'DecisionSummary',
    # Constants
    'MANUAL_PLAYER_ID_START', 'is_manual_player', 'SQUAD_SIZE',
    'STARTING_XI_SIZE', 'MAX_PLAYERS_PER_TEAM', 'CHIP_NAMES',
    'POSITIONS', 'RISK_POSTURES'
]
```

Finalize enhanced_decision_framework.py:
1. Remove all extracted method bodies (keep only delegation)
2. The class should now be a thin orchestrator (~200-400 lines)
3. Add deprecation comment noting modules are preferred
  </action>
  <verify>
```bash
# Verify module extraction
python -c "
from cheddar_fpl_sage.analysis.decision_framework import (
    ChipAnalyzer, TransferAdvisor, CaptainSelector, OutputFormatter
)
print('All 4 domain classes import OK')
"

# CRITICAL: Verify monolith is now significantly smaller (< 1,500 lines, down from 3,681)
python -c "
lines = sum(1 for _ in open('src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py'))
print(f'Orchestrator now {lines} lines (was 3,681)')
assert lines < 1500, f'FAIL: Still too large at {lines} lines (target < 1,500)'
print('Line count reduction VERIFIED')
"

# Verify delegation still works end-to-end
python -c "
from cheddar_fpl_sage.analysis.enhanced_decision_framework import EnhancedDecisionFramework
edf = EnhancedDecisionFramework(manager_id=1, risk_posture='BALANCED')
# Verify all delegation instances exist
assert hasattr(edf, '_chip_analyzer'), 'Missing _chip_analyzer'
assert hasattr(edf, '_transfer_advisor'), 'Missing _transfer_advisor'
assert hasattr(edf, '_captain_selector'), 'Missing _captain_selector'
print('All delegations verified')
"

# Full regression test
pytest tests/ -x -q
```
  </verify>
  <done>OutputFormatter extracted. Package __init__.py exports all classes. EnhancedDecisionFramework reduced from 3,681 to < 1,500 lines (verified). All tests pass.</done>
</task>

<task type="auto">
  <name>Task 4: Implement Manager Risk Tolerance manual input with tri-state precedence</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/constants.py
    src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
    src/cheddar_fpl_sage/analysis/decision_framework/transfer_advisor.py
    fpl_sage.py
    config/team_config.json
    tests/tests_new/test_risk_posture_precedence.py
  </files>
  <action>
Implement manual risk posture override with deterministic precedence: CLI arg > Runtime prompt > team_config.json > BALANCED default.

**Step 1: Define canonical enum and validator in constants.py**

Add to `src/cheddar_fpl_sage/analysis/decision_framework/constants.py`:
```python
# Risk Posture Configuration
RISK_POSTURES = ["CONSERVATIVE", "BALANCED", "AGGRESSIVE"]
DEFAULT_RISK_POSTURE = "BALANCED"

def normalize_risk_posture(value: Optional[str]) -> str:
    """
    Normalize and validate risk posture string.
    
    Args:
        value: User-provided risk posture (case-insensitive) or None
        
    Returns:
        Normalized risk posture (uppercase)
        
    Raises:
        ValueError: If value is not in RISK_POSTURES
    """
    if value is None:
        return DEFAULT_RISK_POSTURE
    
    normalized = value.strip().upper()
    if normalized not in RISK_POSTURES:
        valid = ", ".join(RISK_POSTURES)
        raise ValueError(
            f"Invalid risk posture '{value}'. Must be one of: {valid}"
        )
    return normalized

def get_volatility_multiplier(risk_posture: str) -> float:
    """
    Get volatility penalty multiplier for given risk posture.
    
    CONSERVATIVE: 1.25x (more penalty, avoid volatile transfers)
    BALANCED: 1.0x (neutral)
    AGGRESSIVE: 0.8x (less penalty, tolerate volatility for upside)
    """
    multipliers = {
        "CONSERVATIVE": 1.25,
        "BALANCED": 1.0,
        "AGGRESSIVE": 0.8
    }
    return multipliers.get(risk_posture, 1.0)
```

**Step 2: Add CLI argument to fpl_sage.py**

At the top of `fpl_sage.py`, add argparse:
```python
import argparse

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="FPL Sage - Smart FPL Transfer & Chip Advisor"
    )
    parser.add_argument(
        '--risk-posture',
        type=str,
        choices=['CONSERVATIVE', 'BALANCED', 'AGGRESSIVE'],
        help='Override manager risk tolerance (CONSERVATIVE|BALANCED|AGGRESSIVE)'
    )
    return parser.parse_args()
```

In `main()`, call `args = parse_args()` at the start.

**Step 3: Add runtime prompt in existing "Edit overrides" flow**

In the override editing section of `fpl_sage.py`, add after chip/transfer prompts:
```python
# Inside the "Edit overrides?" section
if edit_overrides.lower() == 'y':
    # ... existing chip/transfer override code ...
    
    # Risk Posture Override
    current_posture = config_manager.get_risk_posture()  # From team_config or default
    if args.risk_posture:
        current_posture = args.risk_posture
        print(f"\nâ„¹ï¸  Risk posture set via CLI: {current_posture}")
    else:
        print(f"\nðŸ“Š Current risk posture: {current_posture}")
        posture_input = input(
            "Set risk posture? (CONSERVATIVE/BALANCED/AGGRESSIVE or blank to keep): "
        ).strip()
        
        if posture_input:
            try:
                from cheddar_fpl_sage.analysis.decision_framework.constants import normalize_risk_posture
                new_posture = normalize_risk_posture(posture_input)
                
                persist = input(f"Persist '{new_posture}' to team_config.json? (y/n): ").strip().lower()
                if persist == 'y':
                    config_manager.set_risk_posture(new_posture, persist=True)
                    print(f"âœ… Saved '{new_posture}' to config")
                else:
                    config_manager.set_risk_posture(new_posture, persist=False)
                    print(f"âœ… Using '{new_posture}' for this run only")
                
                current_posture = new_posture
            except ValueError as e:
                print(f"âŒ {e}")
                print(f"Keeping current posture: {current_posture}")
```

**Step 4: Implement config_manager methods**

Add to config manager (or create utility):
```python
def get_risk_posture(self) -> str:
    """Get risk posture from team config or default."""
    team_config = self.load_team_config()
    posture = team_config.get('risk_posture')
    from cheddar_fpl_sage.analysis.decision_framework.constants import normalize_risk_posture
    return normalize_risk_posture(posture)

def set_risk_posture(self, posture: str, persist: bool = False):
    """Set risk posture, optionally persisting to team_config.json."""
    from cheddar_fpl_sage.analysis.decision_framework.constants import normalize_risk_posture
    normalized = normalize_risk_posture(posture)
    
    if persist:
        team_config = self.load_team_config()
        team_config['risk_posture'] = normalized
        self.save_team_config(team_config)
    else:
        # Store in memory for this run only
        self._runtime_risk_posture = normalized
```

**Step 5: Orchestrator validates and distributes**

In `EnhancedDecisionFramework.__init__`:
```python
def __init__(self, manager_id: int, risk_posture: str = None, ...):
    # Resolve with precedence (CLI > Runtime > Config > Default handled by caller)
    from .decision_framework.constants import normalize_risk_posture
    self.risk_posture = normalize_risk_posture(risk_posture)
    
    # Distribute to modules
    self._chip_analyzer = ChipAnalyzer(risk_posture=self.risk_posture)
    self._transfer_advisor = TransferAdvisor(risk_posture=self.risk_posture)
    self._captain_selector = CaptainSelector(risk_posture=self.risk_posture)
```

**Step 6: Apply volatility multiplier in TransferAdvisor**

In `transfer_advisor.py`, modify plan scoring:
```python
def _score_transfer_plan(self, plan: Dict, ...) -> float:
    # ... existing scoring logic ...
    
    # Apply risk posture to volatility penalty
    from .constants import get_volatility_multiplier
    volatility_multiplier = get_volatility_multiplier(self.risk_posture)
    adjusted_volatility_penalty = base_volatility_penalty * volatility_multiplier
    
    score = (w4 * delta_next4 + w6 * delta_next6 
             + structure_bonus - adjusted_volatility_penalty)
    
    return score
```

**Step 7: Add risk_note traceability**

In output generation (wherever `FplMoveCard` or decision summary is created):
```python
risk_note = f"Manager posture: {self.risk_posture}. {existing_risk_note}"
```

**Step 8: Create acceptance tests**

Create `tests/tests_new/test_risk_posture_precedence.py`:
```python
"""Test risk posture precedence and validation."""
import pytest
from cheddar_fpl_sage.analysis.decision_framework.constants import (
    normalize_risk_posture, get_volatility_multiplier
)

def test_normalize_valid_postures():
    assert normalize_risk_posture("conservative") == "CONSERVATIVE"
    assert normalize_risk_posture("BALANCED") == "BALANCED"
    assert normalize_risk_posture(" aggressive ") == "AGGRESSIVE"

def test_normalize_invalid_posture():
    with pytest.raises(ValueError, match="Invalid risk posture"):
        normalize_risk_posture("YOLO")

def test_normalize_none_returns_default():
    assert normalize_risk_posture(None) == "BALANCED"

def test_volatility_multipliers():
    assert get_volatility_multiplier("CONSERVATIVE") == 1.25
    assert get_volatility_multiplier("BALANCED") == 1.0
    assert get_volatility_multiplier("AGGRESSIVE") == 0.8

def test_orchestrator_validates_posture():
    from cheddar_fpl_sage.analysis.enhanced_decision_framework import EnhancedDecisionFramework
    
    # Valid posture
    edf = EnhancedDecisionFramework(manager_id=1, risk_posture="conservative")
    assert edf.risk_posture == "CONSERVATIVE"
    
    # Invalid posture raises
    with pytest.raises(ValueError):
        EnhancedDecisionFramework(manager_id=1, risk_posture="INVALID")

def test_posture_distributed_to_modules():
    from cheddar_fpl_sage.analysis.enhanced_decision_framework import EnhancedDecisionFramework
    
    edf = EnhancedDecisionFramework(manager_id=1, risk_posture="AGGRESSIVE")
    assert edf._chip_analyzer.risk_posture == "AGGRESSIVE"
    assert edf._transfer_advisor.risk_posture == "AGGRESSIVE"
    assert edf._captain_selector.risk_posture == "AGGRESSIVE"
```

CRITICAL: Keep orchestrator as single validation point. Modules just accept the validated value.
  </action>
  <verify>
```bash
# Test validation and normalization
python -c "
from cheddar_fpl_sage.analysis.decision_framework.constants import normalize_risk_posture, get_volatility_multiplier
assert normalize_risk_posture('conservative') == 'CONSERVATIVE'
assert normalize_risk_posture(None) == 'BALANCED'
assert get_volatility_multiplier('CONSERVATIVE') == 1.25
print('Validation and multipliers OK')
"

# Test orchestrator validates and distributes
python -c "
from cheddar_fpl_sage.analysis.enhanced_decision_framework import EnhancedDecisionFramework
edf = EnhancedDecisionFramework(manager_id=1, risk_posture='aggressive')
assert edf.risk_posture == 'AGGRESSIVE'
assert edf._transfer_advisor.risk_posture == 'AGGRESSIVE'
print('Orchestrator validation and distribution OK')
"

# Run acceptance tests
pytest tests/tests_new/test_risk_posture_precedence.py -v

# Test CLI arg parsing
python fpl_sage.py --help | grep "risk-posture"
```
  </verify>
  <done>Risk posture enum validated centrally. CLI arg, runtime prompt, and team_config.json paths implemented with correct precedence. Volatility multipliers applied in TransferAdvisor. Acceptance tests verify precedence and validation.</done>
</task>

</tasks>

<verification>
Complete module extraction verified:
```bash
# Package structure check
ls -la src/cheddar_fpl_sage/analysis/decision_framework/

# All imports work
python -c "
from cheddar_fpl_sage.analysis.decision_framework import (
    ChipAnalyzer, TransferAdvisor, CaptainSelector, OutputFormatter,
    FPLSageError, TransferRecommendation, is_manual_player
)
print('All imports successful')
"

# Line count reduction (CRITICAL)
echo "Line count verification:"
wc -l src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
# MUST be < 1,500 lines (was 3,681)

# Delegation verification
python -c "
from cheddar_fpl_sage.analysis.enhanced_decision_framework import EnhancedDecisionFramework
edf = EnhancedDecisionFramework(manager_id=1, risk_posture='BALANCED')
assert edf._chip_analyzer is not None
assert edf._transfer_advisor is not None
assert edf._captain_selector is not None
print('Delegation chain verified')
"

# No regression
pytest tests/ -v
```
</verification>

<success_criteria>
- 4 new module files exist (chip_analyzer.py, transfer_advisor.py, captain_selector.py, output_formatter.py)
- Each module has a focused class with related methods
- EnhancedDecisionFramework reduced from 3,681 to < 1,500 lines (MUST verify with wc -l)
- All existing tests pass (delegation is transparent)
- Manual player handling uses is_manual_player() from constants
- Package __init__.py exports all public classes
- Calling EnhancedDecisionFramework.analyze_chip_decision() delegates correctly to ChipAnalyzer
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-stabilization/01-02-SUMMARY.md`
</output>
