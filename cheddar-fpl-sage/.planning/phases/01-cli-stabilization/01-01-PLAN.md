---
phase: 01-cli-stabilization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
  - src/cheddar_fpl_sage/analysis/decision_framework/exceptions.py
  - src/cheddar_fpl_sage/analysis/decision_framework/models.py
  - src/cheddar_fpl_sage/analysis/decision_framework/constants.py
autonomous: true

must_haves:
  truths:
    - "Decision framework raises specific errors when data is invalid (not generic Exception)"
    - "Manual player handling uses configurable ID threshold (not hardcoded 999999)"
    - "Pydantic models validate decision data with clear error messages on invalid input"
  artifacts:
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/__init__.py"
      provides: "Package exports"
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/exceptions.py"
      provides: "Custom exception hierarchy"
      contains: "class FPLSageError"
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/models.py"
      provides: "Pydantic models for decisions"
      contains: "class TransferRecommendation"
    - path: "src/cheddar_fpl_sage/analysis/decision_framework/constants.py"
      provides: "Magic number definitions"
      contains: "MANUAL_PLAYER_ID_START"
  key_links:
    - from: "decision_framework/__init__.py"
      to: "exceptions.py"
      via: "re-exports"
      pattern: "from .exceptions import"
    - from: "decision_framework/__init__.py"
      to: "models.py"
      via: "re-exports"
      pattern: "from .models import"
---

<objective>
Create foundation modules for the decision framework refactor: exception hierarchy, data models, and constants.

Purpose: Establish clean contracts and remove magic numbers BEFORE extracting modules from the monolith. This foundation enables all subsequent refactoring with proper error handling and type safety.

Output: New `decision_framework/` package with exceptions, Pydantic models, and constants that subsequent plans will import.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cli-stabilization/01-RESEARCH.md
@src/cheddar_fpl_sage/analysis/enhanced_decision_framework.py
@src/cheddar_fpl_sage/models/canonical_projections.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exception hierarchy</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
    src/cheddar_fpl_sage/analysis/decision_framework/exceptions.py
  </files>
  <action>
Create the decision_framework package directory and exception module.

In `exceptions.py`, define:
```python
class FPLSageError(Exception):
    """Base exception for all FPL Sage errors"""
    pass

class DataValidationError(FPLSageError):
    """Invalid data structure or missing required fields"""
    pass

class ConfigurationError(FPLSageError):
    """Config file invalid or cannot be loaded"""
    pass

class PlayerNotFoundError(FPLSageError):
    """Player ID or name lookup failed"""
    pass

class ProjectionMissingError(FPLSageError):
    """Required projection data not available"""
    pass

class ChipAnalysisError(FPLSageError):
    """Chip decision logic failed"""
    pass

class TransferValidationError(FPLSageError):
    """Transfer violates squad rules"""
    pass

class FormationError(FPLSageError):
    """Cannot form valid XI with current squad"""
    pass
```

In `__init__.py`, add package docstring and prepare for future exports (will be populated in subsequent tasks).

WHY this hierarchy:
- FPLSageError base allows catching all our errors while letting system exceptions propagate
- Specific types enable targeted handling (retry on network, fail on validation)
- Matches the domain: data, config, players, projections, chips, transfers, formations
  </action>
  <verify>
```bash
python -c "from cheddar_fpl_sage.analysis.decision_framework.exceptions import FPLSageError, DataValidationError, ConfigurationError, PlayerNotFoundError; print('Exceptions import OK')"
```
  </verify>
  <done>All 8 exception classes importable from the package. Base class FPLSageError allows catching all domain errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create Pydantic data models</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/models.py
    src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
  </files>
  <action>
Create Pydantic models for core decision framework data structures. Reference existing dataclasses in `canonical_projections.py` for field naming conventions.

In `models.py`, define:
```python
from pydantic import BaseModel, Field
from typing import Optional, Literal
from datetime import datetime

class TransferRecommendation(BaseModel):
    """Single transfer recommendation with reasoning"""
    player_out_id: int
    player_out_name: str
    player_in_id: int
    player_in_name: str
    position: str
    net_gain_pts: float = Field(description="Expected point gain over horizon")
    reasoning: str
    confidence: Literal["HIGH", "MEDIUM", "LOW"] = "MEDIUM"

class CaptainPick(BaseModel):
    """Captain recommendation with alternatives"""
    captain_id: int
    captain_name: str
    expected_pts: float
    vice_captain_id: int
    vice_captain_name: str
    alternatives: list[dict] = Field(default_factory=list)
    reasoning: str

class ChipRecommendation(BaseModel):
    """Chip usage recommendation"""
    chip: Literal["Wildcard", "Free Hit", "Bench Boost", "Triple Captain", "None"]
    use_this_gw: bool = False
    optimal_window_gw: Optional[int] = None
    reasoning: str
    confidence: Literal["HIGH", "MEDIUM", "LOW"] = "MEDIUM"

class OptimizedXI(BaseModel):
    """Optimized starting XI with formation"""
    formation: str  # e.g., "3-4-3"
    starters: list[dict]  # List of player dicts with id, name, position, expected_pts
    bench: list[dict]
    captain_id: int
    vice_captain_id: int
    total_expected_pts: float

class DecisionSummary(BaseModel):
    """Complete decision output for a gameweek"""
    manager_id: int
    manager_name: str
    gameweek: int
    generated_at: datetime = Field(default_factory=datetime.now)
    transfers: list[TransferRecommendation] = Field(default_factory=list)
    captain: Optional[CaptainPick] = None
    chip: Optional[ChipRecommendation] = None
    optimized_xi: Optional[OptimizedXI] = None
    risk_posture: Literal["CHASE", "DEFEND", "BALANCED"] = "BALANCED"
```

Update `__init__.py` to export exceptions and models:
```python
from .exceptions import (
    FPLSageError, DataValidationError, ConfigurationError,
    PlayerNotFoundError, ProjectionMissingError, ChipAnalysisError,
    TransferValidationError, FormationError
)
from .models import (
    TransferRecommendation, CaptainPick, ChipRecommendation,
    OptimizedXI, DecisionSummary
)
```

WHY Pydantic:
- Validation on construction (catches bad data immediately)
- JSON serialization built-in (model_dump_json)
- Clear schema for API contracts (Phase 2 will use these)
- Type hints for IDE support
  </action>
  <verify>
```bash
python -c "
from cheddar_fpl_sage.analysis.decision_framework import DecisionSummary, TransferRecommendation
tr = TransferRecommendation(player_out_id=1, player_out_name='Salah', player_in_id=2, player_in_name='Haaland', position='FWD', net_gain_pts=2.5, reasoning='Test')
print(tr.model_dump_json())
print('Models import and serialize OK')
"
```
  </verify>
  <done>All 5 Pydantic models importable and serializable. TransferRecommendation validates required fields. DecisionSummary aggregates all decision types.</done>
</task>

<task type="auto">
  <name>Task 3: Create constants module</name>
  <files>
    src/cheddar_fpl_sage/analysis/decision_framework/constants.py
    src/cheddar_fpl_sage/analysis/decision_framework/__init__.py
  </files>
  <action>
Create constants module to replace magic numbers found in the codebase.

In `constants.py`, define:
```python
"""
Constants for FPL decision framework.
Centralizes magic numbers and configuration defaults.
"""

# Manual player identification
# Players manually added (not from FPL API) use IDs >= this value
MANUAL_PLAYER_ID_START = 900000

# Formation constraints (FPL rules)
MIN_GOALKEEPERS = 1
MAX_GOALKEEPERS = 2
MIN_DEFENDERS = 3
MAX_DEFENDERS = 5
MIN_MIDFIELDERS = 2
MAX_MIDFIELDERS = 5
MIN_FORWARDS = 1
MAX_FORWARDS = 3
SQUAD_SIZE = 15
STARTING_XI_SIZE = 11
MAX_PLAYERS_PER_TEAM = 3

# Projection defaults for manual/fallback players
FALLBACK_PROJECTION_PTS = 5.0
FALLBACK_NEXT_3GW_PTS = 15.0
FALLBACK_NEXT_5GW_PTS = 25.0

# Risk posture options
RISK_POSTURES = frozenset(["CHASE", "DEFEND", "BALANCED"])

# Chip names (consistent naming)
CHIP_NAMES = frozenset([
    "Wildcard", "Free Hit", "Bench Boost", "Triple Captain"
])

# Valid positions
POSITIONS = frozenset(["GKP", "DEF", "MID", "FWD"])

# Point horizons for transfer evaluation
TRANSFER_HORIZON_SHORT = 3  # gameweeks
TRANSFER_HORIZON_MEDIUM = 5
TRANSFER_HORIZON_LONG = 8

def is_manual_player(player_id: int) -> bool:
    """Check if a player ID represents a manually added player."""
    return player_id >= MANUAL_PLAYER_ID_START
```

Update `__init__.py` to export constants:
```python
from .constants import (
    MANUAL_PLAYER_ID_START, is_manual_player,
    MIN_GOALKEEPERS, MAX_GOALKEEPERS, MIN_DEFENDERS, MAX_DEFENDERS,
    MIN_MIDFIELDERS, MAX_MIDFIELDERS, MIN_FORWARDS, MAX_FORWARDS,
    SQUAD_SIZE, STARTING_XI_SIZE, MAX_PLAYERS_PER_TEAM,
    FALLBACK_PROJECTION_PTS, FALLBACK_NEXT_3GW_PTS, FALLBACK_NEXT_5GW_PTS,
    RISK_POSTURES, CHIP_NAMES, POSITIONS,
    TRANSFER_HORIZON_SHORT, TRANSFER_HORIZON_MEDIUM, TRANSFER_HORIZON_LONG
)
```

WHY centralize:
- The hardcoded `999999` for Collins is a bug waiting to happen
- Formation rules are FPL official - should be documented in one place
- Fallback projection values should be tunable
- is_manual_player() function makes intent clear vs raw comparison
  </action>
  <verify>
```bash
python -c "
from cheddar_fpl_sage.analysis.decision_framework import is_manual_player, MANUAL_PLAYER_ID_START, SQUAD_SIZE
assert is_manual_player(999999) == True
assert is_manual_player(123) == False
assert SQUAD_SIZE == 15
print('Constants import OK, is_manual_player works')
"
```
  </verify>
  <done>Constants module defines all magic numbers. is_manual_player(999999) returns True. Formation constraints match FPL rules.</done>
</task>

</tasks>

<verification>
All foundation modules in place:
```bash
# Full import test
python -c "
from cheddar_fpl_sage.analysis.decision_framework import (
    # Exceptions
    FPLSageError, DataValidationError, ConfigurationError,
    PlayerNotFoundError, ProjectionMissingError, ChipAnalysisError,
    TransferValidationError, FormationError,
    # Models
    TransferRecommendation, CaptainPick, ChipRecommendation,
    OptimizedXI, DecisionSummary,
    # Constants
    MANUAL_PLAYER_ID_START, is_manual_player, SQUAD_SIZE, CHIP_NAMES
)
print('All foundation imports successful')
"

# Pytest should still pass (no regressions)
pytest tests/ -x -q
```
</verification>

<success_criteria>
- decision_framework/ package exists with 4 files (__init__, exceptions, models, constants)
- 8 exception classes defined and importable
- 5 Pydantic models defined with proper validation
- All magic numbers centralized in constants.py
- is_manual_player() helper function works
- Existing tests still pass (no breaking changes)
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-stabilization/01-01-SUMMARY.md`
</output>
