---
phase: 04-auth-limits
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - frontend/src/components/UsageCounter.tsx
  - frontend/src/components/LimitReached.tsx
  - frontend/src/pages/Landing.tsx
  - frontend/src/pages/Results.tsx
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "Landing page displays usage count on load"
    - "Usage counter updates after analysis completes"
    - "User sees clear message when limit reached"
    - "Blocked user can view their most recent cached results"
    - "Countdown to gameweek reset displayed when blocked"
  artifacts:
    - path: "frontend/src/components/UsageCounter.tsx"
      provides: "Usage display component"
      min_lines: 40
    - path: "frontend/src/components/LimitReached.tsx"
      provides: "Limit reached state UI"
      min_lines: 60
    - path: "frontend/src/lib/api.ts"
      provides: "Usage API client function"
      contains: "getUsage"
  key_links:
    - from: "frontend/src/pages/Landing.tsx"
      to: "frontend/src/lib/api.ts"
      via: "Fetch usage on mount"
      pattern: "getUsage.*useEffect"
    - from: "frontend/src/components/LimitReached.tsx"
      to: "sessionStorage"
      via: "Retrieve cached results"
      pattern: "sessionStorage\\.getItem"
    - from: "frontend/src/lib/api.ts"
      to: "/api/v1/usage/{team_id}"
      via: "HTTP GET request"
      pattern: "fetch.*usage"
---

<objective>
Implement frontend usage display and limit enforcement UI. Show usage counter on landing page, display clear messaging when limit reached, and provide access to cached results.

Purpose: Transparent freemium experience - users know exactly where they stand and what happens at limit.

Output: Working UI that displays usage, blocks gracefully at limit, and provides access to cached results.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-auth-limits/04-CONTEXT.md
@.planning/phases/04-auth-limits/04-01-PLAN.md

# Existing frontend structure
@frontend/src/pages/Landing.tsx
@frontend/src/pages/Results.tsx
@frontend/src/lib/api.ts
@frontend/src/components/RiskPostureSelector.tsx
</context>

<tasks>

<task type="auto">
  <name>Add usage API client and types</name>
  <files>frontend/src/lib/api.ts</files>
  <action>
Add usage tracking API integration to existing api.ts file.

**Add TypeScript types:**
```typescript
export interface UsageData {
  team_id: number
  gameweek: number
  used: number
  limit: number
  remaining: number
  reset_time: number  // Unix timestamp
}
```

**Add getUsage function:**
```typescript
export async function getUsage(teamId: number): Promise<UsageData> {
  const response = await fetch(`${API_BASE_URL}/api/v1/usage/${teamId}`)

  if (!response.ok) {
    const error = await response.json().catch(() => ({}))
    throw new Error(error.detail?.detail || 'Failed to fetch usage data')
  }

  return response.json()
}
```

**Update createAnalysis error handling:**

Enhance existing createAnalysis function to handle 403 USAGE_LIMIT_REACHED errors specifically:

```typescript
// In createAnalysis function, in the error handling block:
if (!response.ok) {
  const error = await response.json().catch(() => ({}))

  // Handle usage limit specifically
  if (response.status === 403 && error.code === 'USAGE_LIMIT_REACHED') {
    const limitError: any = new Error(error.detail?.detail || 'Usage limit reached')
    limitError.code = 'USAGE_LIMIT_REACHED'
    limitError.used = error.detail?.used
    limitError.limit = error.detail?.limit
    limitError.reset_time = error.detail?.reset_time
    throw limitError
  }

  // Existing error handling for other cases...
}
```

This allows frontend to catch and display usage-specific errors with full context.
  </action>
  <verify>
```bash
# Check types added
grep "interface UsageData" frontend/src/lib/api.ts

# Check function added
grep "export async function getUsage" frontend/src/lib/api.ts

# Check error handling enhanced
grep "USAGE_LIMIT_REACHED" frontend/src/lib/api.ts

# Run TypeScript compiler
cd frontend && npm run build -- --mode development || echo "Build check"
```
  </verify>
  <done>
- UsageData interface exported from api.ts
- getUsage(teamId) function fetches from /api/v1/usage/{teamId}
- createAnalysis enhanced to parse 403 USAGE_LIMIT_REACHED errors
- Error object includes used, limit, reset_time for UI display
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Create usage counter component</name>
  <files>frontend/src/components/UsageCounter.tsx</files>
  <action>
Create `UsageCounter` component that displays current usage in a non-intrusive way.

**Component requirements:**

```typescript
import { useEffect, useState } from 'react'
import { getUsage, type UsageData } from '@/lib/api'

interface UsageCounterProps {
  teamId: number | null
  onUsageUpdate?: (usage: UsageData) => void
}

export default function UsageCounter({ teamId, onUsageUpdate }: UsageCounterProps) {
  const [usage, setUsage] = useState<UsageData | null>(null)
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    if (!teamId) return

    setLoading(true)
    getUsage(teamId)
      .then(data => {
        setUsage(data)
        onUsageUpdate?.(data)
      })
      .catch(err => {
        console.error('Failed to fetch usage:', err)
        // Fail silently - usage display is non-critical
      })
      .finally(() => setLoading(false))
  }, [teamId, onUsageUpdate])

  if (!usage || loading) return null

  const isNearLimit = usage.remaining <= 0
  const isWarning = usage.remaining === 1

  return (
    <div className={`text-sm ${isNearLimit ? 'text-red-400' : isWarning ? 'text-yellow-400' : 'text-gray-400'}`}>
      <span>{usage.used} of {usage.limit} analyses used this gameweek</span>
      {isNearLimit && (
        <span className="ml-2 text-xs">
          (Resets in GW{usage.gameweek + 1})
        </span>
      )}
    </div>
  )
}
```

**Design notes:**
- Non-intrusive: Small text, bottom of team ID input or top of page
- Color coding: gray (normal), yellow (1 remaining), red (0 remaining)
- Silent failure if API unavailable (non-blocking)
- Callback prop allows parent to cache usage data
- No loading spinner (to avoid visual noise)

**Styling approach:**
Use existing Tailwind classes consistent with Landing.tsx aesthetic (dark mode, clinical).
  </action>
  <verify>
```bash
# Component exists
test -f frontend/src/components/UsageCounter.tsx && echo "Component created"

# Check imports
grep "getUsage" frontend/src/components/UsageCounter.tsx

# Run dev build
cd frontend && npm run dev -- --mode development 2>&1 | head -20 || echo "Check compilation"
```
  </verify>
  <done>
- UsageCounter component accepts teamId prop
- Fetches usage data via getUsage API
- Displays "X of 2 analyses used this gameweek"
- Color codes: gray (safe), yellow (1 left), red (at limit)
- Fails silently if API unavailable
- Callback prop for parent to track usage state
  </done>
</task>

<task type="auto">
  <name>Create limit reached component</name>
  <files>frontend/src/components/LimitReached.tsx</files>
  <action>
Create `LimitReached` component that displays when user hits limit. Shows clear messaging + countdown + access to cached results.

**Component structure:**

```typescript
import { useEffect, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { Card } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'

interface LimitReachedProps {
  teamId: number
  used: number
  limit: number
  resetTime: number  // Unix timestamp
}

export default function LimitReached({ teamId, used, limit, resetTime }: LimitReachedProps) {
  const navigate = useNavigate()
  const [timeUntilReset, setTimeUntilReset] = useState('')

  useEffect(() => {
    const updateCountdown = () => {
      const now = Math.floor(Date.now() / 1000)
      const secondsLeft = resetTime - now

      if (secondsLeft <= 0) {
        setTimeUntilReset('Available now')
        return
      }

      // Format as "X days Y hours" or "Y hours Z mins" or "Z minutes"
      const days = Math.floor(secondsLeft / 86400)
      const hours = Math.floor((secondsLeft % 86400) / 3600)
      const mins = Math.floor((secondsLeft % 3600) / 60)

      if (days > 0) {
        setTimeUntilReset(`${days}d ${hours}h`)
      } else if (hours > 0) {
        setTimeUntilReset(`${hours}h ${mins}m`)
      } else {
        setTimeUntilReset(`${mins} minutes`)
      }
    }

    updateCountdown()
    const interval = setInterval(updateCountdown, 60000) // Update every minute

    return () => clearInterval(interval)
  }, [resetTime])

  const handleViewCached = () => {
    // Look for most recent cached analysis in sessionStorage
    // Format: analysis_{analysis_id} from Landing.tsx
    const keys = Object.keys(sessionStorage).filter(k => k.startsWith('analysis_'))
    if (keys.length === 0) {
      alert('No cached results available')
      return
    }

    // Find most recent (sessionStorage doesn't have timestamps, use last key)
    const lastKey = keys[keys.length - 1]
    const analysisId = lastKey.replace('analysis_', '')
    navigate(`/results/${analysisId}`)
  }

  return (
    <Card className="p-6 border-red-500/50 bg-red-950/20">
      <div className="space-y-4">
        <Alert variant="destructive">
          <AlertDescription>
            <strong>Free tier limit reached</strong>
            <p className="mt-2">
              You've used all {limit} free analyses for this gameweek.
            </p>
          </AlertDescription>
        </Alert>

        <div className="text-sm text-gray-400">
          <p>Your next analysis will be available when the next gameweek starts.</p>
          <p className="mt-2 text-lg text-white">
            Next analysis in: <strong>{timeUntilReset}</strong>
          </p>
        </div>

        <div className="flex gap-3">
          <Button
            variant="outline"
            onClick={handleViewCached}
            className="flex-1"
          >
            View Your Latest Results
          </Button>
        </div>

        <p className="text-xs text-gray-500 text-center">
          Tip: Bookmark your results page to access recommendations anytime
        </p>
      </div>
    </Card>
  )
}
```

**Design rationale:**
- Clear, non-punishing tone ("next analysis available when...")
- Countdown creates urgency but shows transparency
- Access to cached results maintains value even at limit
- No upgrade CTA (Stripe deferred per CONTEXT.md)
- Red accent but not aggressive (border, not full background)

**Cached results access:**
Landing.tsx already stores cached results in sessionStorage as `analysis_{id}`. LimitReached provides easy access to view those again.
  </action>
  <verify>
```bash
# Component exists
test -f frontend/src/components/LimitReached.tsx && echo "Component created"

# Check countdown logic
grep "setTimeUntilReset" frontend/src/components/LimitReached.tsx

# Check cached results navigation
grep "navigate.*results" frontend/src/components/LimitReached.tsx

# TypeScript compile check
cd frontend && npm run build -- --mode development || echo "Build check"
```
  </verify>
  <done>
- LimitReached component displays when limit hit
- Shows countdown to next gameweek (days/hours/minutes)
- "View Your Latest Results" button navigates to cached analysis
- Clear, transparent messaging (not punishing)
- No upgrade prompts (Stripe deferred)
- Uses existing shadcn/ui components (Card, Alert, Button)
  </done>
</task>

<task type="auto">
  <name>Integrate usage display and limit handling in Landing page</name>
  <files>frontend/src/pages/Landing.tsx</files>
  <action>
Integrate UsageCounter and LimitReached components into existing Landing page flow.

**Changes to Landing.tsx:**

1. **Add imports:**
```typescript
import UsageCounter from '@/components/UsageCounter'
import LimitReached from '@/components/LimitReached'
import type { UsageData } from '@/lib/api'
```

2. **Add state for usage and limit:**
```typescript
const [usageData, setUsageData] = useState<UsageData | null>(null)
const [limitReached, setLimitReached] = useState(false)
```

3. **Add UsageCounter after team ID input (when teamId set):**

Find the section after team ID is entered (step === 'team-id'). Add UsageCounter below the input:

```typescript
{/* After team ID input field */}
{teamId && (
  <div className="mt-2">
    <UsageCounter
      teamId={parseInt(teamId)}
      onUsageUpdate={(usage) => {
        setUsageData(usage)
        setLimitReached(usage.remaining <= 0)
      }}
    />
  </div>
)}
```

4. **Show LimitReached instead of analysis flow if at limit:**

Before the runAnalysis call, check limitReached:

```typescript
const runAnalysis = async () => {
  // Check if already at limit
  if (limitReached && usageData) {
    // Show limit reached UI instead of trying to run analysis
    return
  }

  setLoading(true)
  setError(null)
  // ... existing analysis logic
}
```

5. **Catch 403 USAGE_LIMIT_REACHED errors in runAnalysis:**

In the catch block of runAnalysis:

```typescript
} catch (err: any) {
  console.error('Analysis failed:', err)

  // Handle usage limit reached
  if (err.code === 'USAGE_LIMIT_REACHED') {
    setLimitReached(true)
    setUsageData({
      team_id: id,
      gameweek: 0, // Will be populated by error
      used: err.used || limit,
      limit: err.limit || 2,
      remaining: 0,
      reset_time: err.reset_time || 0,
    })
    setError(null) // Don't show generic error
  } else {
    setError(err.message || 'Analysis failed')
  }
} finally {
  setLoading(false)
}
```

6. **Render LimitReached when blocked:**

Add before the main flow steps:

```typescript
{limitReached && usageData && (
  <LimitReached
    teamId={parseInt(teamId)}
    used={usageData.used}
    limit={usageData.limit}
    resetTime={usageData.reset_time}
  />
)}

{!limitReached && (
  // Existing flow (step === 'team-id', 'chip-setup', etc.)
)}
```

**Integration notes:**
- UsageCounter shows immediately when team_id entered
- Updates after each successful analysis
- LimitReached replaces entire flow when blocked
- Cached results button navigates to most recent analysis
- User can change team_id to start fresh with different team

**Preserve existing functionality:**
All existing 6-step flow, WebSocket progress, manual overrides remain unchanged. Only additions are usage display and limit gate.
  </action>
  <verify>
```bash
# Check imports added
grep -E "UsageCounter|LimitReached" frontend/src/pages/Landing.tsx

# Check state added
grep "limitReached" frontend/src/pages/Landing.tsx

# Check error handling
grep "USAGE_LIMIT_REACHED" frontend/src/pages/Landing.tsx

# Build frontend
cd frontend && npm run build || echo "Check for errors"

# Manual test: Visit landing page, enter team ID, see usage counter
```
  </verify>
  <done>
- UsageCounter rendered after team ID input
- Updates when analysis completes via callback
- LimitReached component shown when limit hit (replaces flow)
- createAnalysis catches 403 errors and sets limitReached state
- Blocked users can view cached results via LimitReached button
- Usage counter color-codes based on remaining (gray/yellow/red)
- All existing flow functionality preserved
  </done>
</task>

<task type="auto">
  <name>Update Results page to handle usage context</name>
  <files>frontend/src/pages/Results.tsx</files>
  <action>
Add usage context awareness to Results page. Show post-analysis usage info and handle "accessed from LimitReached" state.

**Changes to Results.tsx:**

1. **Add UsageCounter import:**
```typescript
import UsageCounter from '@/components/UsageCounter'
```

2. **Extract team_id from results:**

Results page already loads analysis data. Extract team_id from results to pass to UsageCounter:

```typescript
// In Results component, after results are loaded
const teamId = results?.team_id || null
```

3. **Add UsageCounter at bottom of Results page:**

Add after the main results display (after all tabs/sections):

```typescript
{teamId && (
  <div className="mt-6 pt-4 border-t border-gray-800">
    <UsageCounter teamId={teamId} />
    <p className="text-xs text-gray-500 mt-2">
      Each analysis counts toward your gameweek limit
    </p>
  </div>
)}
```

**Optional enhancement (if team_id not in results):**

If results don't include team_id, extract from URL or sessionStorage key:

```typescript
// From URL: /results/:analysisId
// Or from sessionStorage key: analysis_{id}
const analysisId = // ... from useParams or props
const cachedData = sessionStorage.getItem(`analysis_${analysisId}`)
const teamId = cachedData ? JSON.parse(cachedData).request?.team_id : null
```

**Why show usage on Results page:**
- User sees updated count after analysis completes
- Reinforces freemium model transparently
- Provides context if they're approaching limit

**Design placement:**
Bottom of page, subtle, informational only. Not blocking or aggressive.
  </action>
  <verify>
```bash
# Check import added
grep "UsageCounter" frontend/src/pages/Results.tsx

# Check rendered
grep "teamId.*UsageCounter" frontend/src/pages/Results.tsx

# Build check
cd frontend && npm run build || echo "Check for errors"

# Manual test: Complete analysis, check Results page shows usage
```
  </verify>
  <done>
- UsageCounter displayed at bottom of Results page
- Extracts team_id from results or cached data
- Shows updated usage count after analysis
- Subtle placement (border-top, bottom of page)
- Non-blocking, informational only
  </done>
</task>

</tasks>

<verification>
**End-to-end verification flow:**

1. **Start full stack:**
```bash
# Terminal 1: Redis
redis-server

# Terminal 2: Backend
cd backend && uvicorn backend.main:app --reload

# Terminal 3: Frontend
cd frontend && npm run dev
```

2. **Test first analysis:**
- Visit http://localhost:5173
- Enter team ID: 711511
- Observe usage counter: "0 of 2 analyses used this gameweek"
- Complete flow (chip setup → risk → manual → run analysis)
- On Results page, observe: "1 of 2 analyses used this gameweek"

3. **Test second analysis:**
- Go back to Landing (or refresh)
- Enter same team ID: 711511
- Observe usage counter: "1 of 2 analyses used this gameweek" (yellow)
- Complete analysis
- On Results page, observe: "2 of 2 analyses used this gameweek" (red)

4. **Test limit enforcement:**
- Go back to Landing
- Enter same team ID: 711511
- Observe usage counter: "2 of 2 analyses used this gameweek" (red, with reset message)
- Try to run analysis
- Observe LimitReached component replaces flow
- See countdown: "Next analysis in: 3d 12h" (or similar)
- Click "View Your Latest Results"
- Navigate to most recent cached analysis

5. **Test independent quotas:**
- Go back to Landing
- Enter different team ID: 999999
- Observe usage counter: "0 of 2 analyses used this gameweek"
- Complete analysis successfully (not blocked)
- Confirms quotas are per-team_id

6. **Test UI states:**
- Gray text when 0-1 used (safe)
- Yellow text when 1 used (warning)
- Red text when 2 used (at limit)
- LimitReached card styling (red accent, not aggressive)
- Countdown updates (wait 1 minute, check countdown decrements)

7. **Test graceful degradation:**
- Stop Redis: `redis-cli shutdown`
- Try to run analysis
- Should succeed (backend logs warning, no usage tracking)
- Usage counter should not display (silent failure)
- Restart Redis for next test

**Expected behavior summary:**
- Usage counter always visible when team_id entered
- Updates immediately after analysis completes
- Blocks at limit with clear messaging
- Countdown shows time to reset
- Access to cached results maintained
- Different team_ids independent
- Graceful degradation when Redis down

</verification>

<success_criteria>
**Frontend usage UI complete when:**
- [ ] UsageCounter component displays on Landing page after team ID entry
- [ ] Usage count updates after successful analysis
- [ ] Color coding works: gray (safe), yellow (1 left), red (at limit)
- [ ] LimitReached component displays when limit hit
- [ ] Countdown to gameweek reset shows correctly
- [ ] "View Your Latest Results" navigates to cached analysis
- [ ] Results page shows usage counter at bottom
- [ ] Different team_ids have independent usage displays
- [ ] 403 USAGE_LIMIT_REACHED errors caught and handled gracefully
- [ ] UI fails silently if usage API unavailable (non-blocking)
- [ ] All existing Landing flow functionality preserved
- [ ] Manual testing confirms full flow (0 → 1 → 2 → blocked → cached)
</success_criteria>

<output>
After completion, create `.planning/phases/04-auth-limits/04-02-SUMMARY.md` following the summary template.

Include:
- Component structure (UsageCounter, LimitReached)
- Integration points in Landing and Results pages
- Error handling for 403 responses
- UI state management (usage data, limitReached flag)
- Cached results access mechanism
- Manual test results and screenshots (if captured)
</output>
